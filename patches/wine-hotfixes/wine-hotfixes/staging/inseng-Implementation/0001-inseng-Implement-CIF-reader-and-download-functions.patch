From eee60c1777c710cfcb4283922990a306361548ba Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Mon, 5 Sep 2016 15:31:29 +0200
Subject: [PATCH] inseng: Implement CIF reader and download functions.

FIXME: Needs splitting.
---
 dlls/inseng/Makefile.in      |    7 +-
 dlls/inseng/icif.c           | 1745 ++++++++++++++++++++++++++++++++++
 dlls/inseng/inf.c            |  443 +++++++++
 dlls/inseng/inseng.spec      |    4 +-
 dlls/inseng/inseng_main.c    |  990 ++++++++++++++++++-
 dlls/inseng/inseng_private.h |   79 ++
 include/inseng.idl           |  276 +++++-
 7 files changed, 3490 insertions(+), 54 deletions(-)
 create mode 100644 dlls/inseng/icif.c
 create mode 100644 dlls/inseng/inf.c
 create mode 100644 dlls/inseng/inseng_private.h

diff --git a/dlls/inseng/Makefile.in b/dlls/inseng/Makefile.in
index 0217203791a..ba2388c97ed 100644
--- a/dlls/inseng/Makefile.in
+++ b/dlls/inseng/Makefile.in
@@ -1,8 +1,11 @@
 MODULE    = inseng.dll
-IMPORTS   = uuid ole32 advapi32
+IMPORTS   = uuid ole32 advapi32 urlmon shlwapi
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
-C_SRCS = inseng_main.c
+C_SRCS = \
+	icif.c \
+	inf.c \
+	inseng_main.c
 
 IDL_SRCS = inseng_classes.idl
diff --git a/dlls/inseng/icif.c b/dlls/inseng/icif.c
new file mode 100644
index 00000000000..11a91b86476
--- /dev/null
+++ b/dlls/inseng/icif.c
@@ -0,0 +1,1745 @@
+/*
+ * Copyright 2016 Michael MÃ¼ller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+
+
+
+#include <stdarg.h>
+#include <string.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "ole2.h"
+#include "rpcproxy.h"
+#include "inseng.h"
+
+#include "inseng_private.h"
+
+#include "wine/list.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(inseng);
+
+#define DEFAULT_INSTALLER_DESC "Active Setup Installation"
+
+struct cifgroup
+{
+    ICifGroup ICifGroup_iface;
+
+    struct list entry;
+
+    ICifFile *parent;
+
+    char *id;
+    char *description;
+    DWORD priority;
+};
+
+struct ciffenum_components
+{
+    IEnumCifComponents IEnumCifComponents_iface;
+    LONG ref;
+
+    ICifFile *file;
+    struct list *start;
+    struct list *position;
+
+    char *group_id;
+};
+
+struct ciffenum_groups
+{
+    IEnumCifGroups IEnumCifGroups_iface;
+    LONG ref;
+
+    ICifFile *file;
+    struct list *start;
+    struct list *position;
+};
+
+struct url_info
+{
+    struct list entry;
+    INT index;
+    char *url;
+    DWORD flags;
+};
+
+struct dependency_info
+{
+    struct list entry;
+    char *id;
+    char *type;
+};
+
+struct cifcomponent
+{
+    ICifComponent ICifComponent_iface;
+
+    struct list entry;
+
+    ICifFile *parent;
+
+    char *id;
+    char *guid;
+    char *description;
+    char *details;
+    char *group;
+
+
+    DWORD version;
+    DWORD build;
+    char *patchid;
+
+    char *locale;
+    char *key_uninstall;
+
+    DWORD size_win;
+    DWORD size_app;
+    DWORD size_download;
+    DWORD size_extracted;
+
+    char *key_success;
+    char *key_progress;
+    char *key_cancel;
+
+    DWORD as_aware;
+    DWORD reboot;
+    DWORD admin;
+    DWORD visibleui;
+
+    DWORD priority;
+    DWORD platform;
+
+    struct list dependencies;
+    struct list urls;
+
+    /* mode */
+    /* det version */
+    /* one component */
+    /* custom data */
+
+    /* in memory state */
+    DWORD queue_state;
+    DWORD current_priority;
+    DWORD size_actual_download;
+    BOOL downloaded;
+    BOOL installed;
+};
+
+struct ciffile
+{
+    ICifFile ICifFile_iface;
+    LONG ref;
+
+    struct list components;
+    struct list groups;
+
+    char *name;
+};
+
+static inline struct ciffile *impl_from_ICiffile(ICifFile *iface)
+{
+    return CONTAINING_RECORD(iface, struct ciffile, ICifFile_iface);
+}
+
+static inline struct cifcomponent *impl_from_ICifComponent(ICifComponent *iface)
+{
+    return CONTAINING_RECORD(iface, struct cifcomponent, ICifComponent_iface);
+}
+
+static inline struct cifgroup *impl_from_ICifGroup(ICifGroup *iface)
+{
+    return CONTAINING_RECORD(iface, struct cifgroup, ICifGroup_iface);
+}
+
+static inline struct ciffenum_components *impl_from_IEnumCifComponents(IEnumCifComponents *iface)
+{
+    return CONTAINING_RECORD(iface, struct ciffenum_components, IEnumCifComponents_iface);
+}
+
+static inline struct ciffenum_groups *impl_from_IEnumCifGroups(IEnumCifGroups *iface)
+{
+    return CONTAINING_RECORD(iface, struct ciffenum_groups, IEnumCifGroups_iface);
+}
+
+static HRESULT enum_components_create(ICifFile *file, struct list *start, char *group_id, IEnumCifComponents **iface);
+
+static HRESULT copy_substring_null(char *dest, int max_len, char *src)
+{
+    if (!src)
+        return E_FAIL;
+
+    if (max_len <= 0)
+        return S_OK;
+
+    if (!dest)
+        return E_FAIL;
+
+    while (*src && max_len-- > 1)
+        *dest++ = *src++;
+    *dest = 0;
+
+    return S_OK;
+}
+
+static void url_entry_free(struct url_info *url)
+{
+    heap_free(url->url);
+    heap_free(url);
+}
+
+static void dependency_entry_free(struct dependency_info *dependency)
+{
+    heap_free(dependency->id);
+    heap_free(dependency);
+}
+
+static void component_free(struct cifcomponent *comp)
+{
+    struct dependency_info *dependency, *dependency_next;
+    struct url_info *url, *url_next;
+
+    heap_free(comp->id);
+    heap_free(comp->guid);
+    heap_free(comp->description);
+    heap_free(comp->details);
+    heap_free(comp->group);
+
+    heap_free(comp->patchid);
+
+    heap_free(comp->locale);
+    heap_free(comp->key_uninstall);
+
+    heap_free(comp->key_success);
+    heap_free(comp->key_progress);
+    heap_free(comp->key_cancel);
+
+    LIST_FOR_EACH_ENTRY_SAFE(dependency, dependency_next, &comp->dependencies, struct dependency_info, entry)
+    {
+        list_remove(&dependency->entry);
+        dependency_entry_free(dependency);
+    }
+
+    LIST_FOR_EACH_ENTRY_SAFE(url, url_next, &comp->urls, struct url_info, entry)
+    {
+        list_remove(&url->entry);
+        url_entry_free(url);
+    }
+
+    heap_free(comp);
+}
+
+static void group_free(struct cifgroup *group)
+{
+    heap_free(group->id);
+    heap_free(group->description);
+    heap_free(group);
+}
+
+static HRESULT WINAPI group_GetID(ICifGroup *iface, char *id, DWORD size)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->id);
+}
+
+static HRESULT WINAPI group_GetDescription(ICifGroup *iface, char *desc, DWORD size)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, desc, size);
+
+    return copy_substring_null(desc, size, This->description);
+}
+
+static DWORD WINAPI group_GetPriority(ICifGroup *iface)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->priority;
+}
+
+static HRESULT WINAPI group_EnumComponents(ICifGroup *iface, IEnumCifComponents **enum_components, DWORD filter, LPVOID pv)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+    struct ciffile *file;
+
+    TRACE("(%p)->(%p, %u, %p)\n", This, enum_components, filter, pv);
+
+    if (filter)
+        FIXME("filter (%x) not supported\n", filter);
+    if (pv)
+        FIXME("how to handle pv (%p)?\n", pv);
+
+    file = impl_from_ICiffile(This->parent);
+    return enum_components_create(This->parent, &file->components, This->id, enum_components);
+}
+
+static DWORD WINAPI group_GetCurrentPriority(ICifGroup *iface)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    FIXME("(%p): stub\n", This);
+
+    return 0;
+}
+
+static const ICifGroupVtbl cifgroupVtbl =
+{
+    group_GetID,
+    group_GetDescription,
+    group_GetPriority,
+    group_EnumComponents,
+    group_GetCurrentPriority,
+};
+
+void component_set_actual_download_size(ICifComponent *iface, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    This->size_actual_download = size;
+}
+
+void component_set_downloaded(ICifComponent *iface, BOOL value)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    This->downloaded = value;
+}
+
+void component_set_installed(ICifComponent *iface, BOOL value)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    This->installed = value;
+}
+
+char *component_get_id(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    return This->id;
+}
+
+static HRESULT WINAPI component_GetID(ICifComponent *iface, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->id);
+}
+
+static HRESULT WINAPI component_GetGUID(ICifComponent *iface, char *guid, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, guid, size);
+
+    return copy_substring_null(guid, size, This->guid);
+}
+
+static HRESULT WINAPI component_GetDescription(ICifComponent *iface, char *desc, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, desc, size);
+
+    return copy_substring_null(desc, size, This->description);
+}
+
+static HRESULT WINAPI component_GetDetails(ICifComponent *iface, char *details, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, details, size);
+
+    return copy_substring_null(details, size, This->details);
+}
+
+static HRESULT WINAPI component_GetUrl(ICifComponent *iface, UINT index, char *url, DWORD size, DWORD *flags)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+    struct url_info *entry;
+
+    TRACE("(%p)->(%u, %p, %u, %p)\n", This, index, url, size, flags);
+
+    /* FIXME: check how functions behaves for url == NULL */
+
+    if (!flags)
+        return E_FAIL;
+
+    LIST_FOR_EACH_ENTRY(entry, &This->urls, struct url_info, entry)
+    {
+        if (entry->index != index)
+            continue;
+
+        *flags = entry->flags;
+        return copy_substring_null(url, size, entry->url);
+    }
+
+    return E_FAIL;
+}
+
+static HRESULT WINAPI component_GetFileExtractList(ICifComponent *iface, UINT index, char *list, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %u): stub\n", This, index, list, size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetUrlCheckRange(ICifComponent *iface, UINT index, DWORD *min, DWORD *max)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %p): stub\n", This, index, min, max);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetCommand(ICifComponent *iface, UINT index, char *cmd, DWORD cmd_size, char *switches, DWORD switch_size, DWORD *type)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %u, %p, %u, %p): stub\n", This, index, cmd, cmd_size, switches, switch_size, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetVersion(ICifComponent *iface, DWORD *version, DWORD *build)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, version, build);
+
+    if (!version || !build)
+        return E_FAIL;
+
+    *version = This->version;
+    *build = This->build;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI component_GetLocale(ICifComponent *iface, char *locale, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, locale, size);
+
+    return copy_substring_null(locale, size, This->locale);
+}
+
+static HRESULT WINAPI component_GetUninstallKey(ICifComponent *iface, char *key, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, key, size);
+
+    return copy_substring_null(key, size, This->key_uninstall);
+}
+
+static HRESULT WINAPI component_GetInstalledSize(ICifComponent *iface, DWORD *win, DWORD *app)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, win, app);
+
+    if (!win || !app)
+        return E_FAIL;
+
+    *win = This->size_win;
+    *app = This->size_app;
+
+    return S_OK;
+}
+
+static DWORD WINAPI component_GetDownloadSize(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->size_download;
+}
+
+static DWORD WINAPI component_GetExtractSize(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->size_extracted;
+}
+
+static HRESULT WINAPI component_GetSuccessKey(ICifComponent *iface, char *key, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, key, size);
+
+    return copy_substring_null(key, size, This->key_success);
+}
+
+static HRESULT WINAPI component_GetProgressKeys(ICifComponent *iface, char *progress, DWORD progress_size,
+                                                char *cancel, DWORD cancel_size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %u, %p, %u): semi-stub\n", This, progress, progress_size, cancel, cancel_size);
+
+    hr = copy_substring_null(progress, progress_size, This->key_progress);
+    if (hr != S_OK) return hr;
+
+    if (cancel_size > 0 && cancel)
+        *cancel = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI component_IsActiveSetupAware(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->as_aware ? S_OK : S_FALSE;
+}
+
+static HRESULT WINAPI component_IsRebootRequired(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->reboot ? S_OK : S_FALSE;
+}
+
+static HRESULT WINAPI component_RequiresAdminRights(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->admin ? S_OK : S_FALSE;
+}
+
+static DWORD WINAPI component_GetPriority(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->priority;
+}
+
+static HRESULT WINAPI component_GetDependency(ICifComponent *iface, UINT index, char *id, DWORD id_size, char *type, DWORD *ver, DWORD *build)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+    struct dependency_info *entry;
+    ICifComponent *dependency;
+    int pos = 0;
+
+    TRACE("(%p)->(%u, %p, %u, %p, %p, %p)\n", This, index, id, id_size, type, ver, build);
+
+    if (!id || !ver || !build)
+        return E_FAIL;
+
+    LIST_FOR_EACH_ENTRY(entry, &This->dependencies, struct dependency_info, entry)
+    {
+        if (pos++ < index)
+            continue;
+
+        if (ICifFile_FindComponent(This->parent, entry->id, &dependency) == S_OK)
+        {
+            ICifComponent_GetVersion(dependency, ver, build);
+        }
+        else
+        {
+            *ver = -1;
+            *build = -1;
+        }
+
+        if (entry->type)
+            *type = *entry->type;
+        else
+            *type = 'I';
+
+        return copy_substring_null(id, id_size, entry->id);
+    }
+
+    return E_FAIL;
+}
+
+static DWORD WINAPI component_GetPlatform(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->platform;
+}
+
+static HRESULT WINAPI component_GetMode(ICifComponent *iface, UINT index, char *mode, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %u): stub\n", This, index, mode, size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetGroup(ICifComponent *iface, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->group);
+}
+
+static HRESULT WINAPI component_IsUIVisible(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->visibleui ? S_OK : S_FALSE;
+}
+
+static HRESULT WINAPI component_GetPatchID(ICifComponent *iface, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->patchid);
+}
+
+static HRESULT WINAPI component_GetDetVersion(ICifComponent *iface, char *dll, DWORD dll_size, char *entry, DWORD entry_size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%p, %u, %p, %u): stub\n", This, dll, dll_size, entry, entry_size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetTreatAsOneComponents(ICifComponent *iface, UINT index, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %u): stub\n", This, index, id, size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetCustomData(ICifComponent *iface, char *key, char *data, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%s, %p, %u): stub\n", This, debugstr_a(key), data, size);
+
+    return E_NOTIMPL;
+}
+
+static DWORD WINAPI component_IsComponentInstalled(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->installed;
+}
+
+static HRESULT WINAPI component_IsComponentDownloaded(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->downloaded ? S_OK : S_FALSE;
+}
+
+static DWORD WINAPI component_IsThisVersionInstalled(ICifComponent *iface, DWORD version, DWORD build, DWORD *ret_version, DWORD *ret_build)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %u, %p, %p): stub\n", This, version, build, ret_version, ret_build);
+
+    return 0;
+}
+
+static DWORD WINAPI component_GetInstallQueueState(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->queue_state;
+}
+
+static HRESULT WINAPI component_SetInstallQueueState(ICifComponent *iface, DWORD state)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%u)\n", This, state);
+
+    This->queue_state = state;
+    return S_OK;
+}
+
+static DWORD WINAPI component_GetActualDownloadSize(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->size_download;
+}
+
+static DWORD WINAPI component_GetCurrentPriority(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->current_priority;
+}
+
+
+static HRESULT WINAPI component_SetCurrentPriority(ICifComponent *iface, DWORD priority)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%u)\n", This, priority);
+
+    This->current_priority = priority;
+    return S_OK;
+}
+
+static const ICifComponentVtbl cifcomponentVtbl =
+{
+    component_GetID,
+    component_GetGUID,
+    component_GetDescription,
+    component_GetDetails,
+    component_GetUrl,
+    component_GetFileExtractList,
+    component_GetUrlCheckRange,
+    component_GetCommand,
+    component_GetVersion,
+    component_GetLocale,
+    component_GetUninstallKey,
+    component_GetInstalledSize,
+    component_GetDownloadSize,
+    component_GetExtractSize,
+    component_GetSuccessKey,
+    component_GetProgressKeys,
+    component_IsActiveSetupAware,
+    component_IsRebootRequired,
+    component_RequiresAdminRights,
+    component_GetPriority,
+    component_GetDependency,
+    component_GetPlatform,
+    component_GetMode,
+    component_GetGroup,
+    component_IsUIVisible,
+    component_GetPatchID,
+    component_GetDetVersion,
+    component_GetTreatAsOneComponents,
+    component_GetCustomData,
+    component_IsComponentInstalled,
+    component_IsComponentDownloaded,
+    component_IsThisVersionInstalled,
+    component_GetInstallQueueState,
+    component_SetInstallQueueState,
+    component_GetActualDownloadSize,
+    component_GetCurrentPriority,
+    component_SetCurrentPriority,
+};
+
+static HRESULT WINAPI enum_components_QueryInterface(IEnumCifComponents *iface, REFIID riid, void **ppv)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->IEnumCifComponents_iface;
+    }
+    /*
+    else if (IsEqualGUID(&IID_IEnumCifComponents, riid))
+    {
+        TRACE("(%p)->(IID_ICifFile %p)\n", This, ppv);
+        *ppv = &This->IEnumCifComponents_iface;
+    }
+    */
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI enum_components_AddRef(IEnumCifComponents *iface)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI enum_components_Release(IEnumCifComponents *iface)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    if(!ref)
+    {
+        ICifFile_Release(This->file);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI enum_components_Next(IEnumCifComponents *iface, ICifComponent **component)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+    struct cifcomponent *comp;
+
+    TRACE("(%p)->(%p)\n", This, component);
+
+    if (!component)
+        return E_FAIL;
+
+    if (!This->position)
+    {
+        *component = NULL;
+        return E_FAIL;
+    }
+
+    do
+    {
+        This->position = list_next(This->start, This->position);
+        if (!This->position)
+        {
+            *component = NULL;
+            return E_FAIL;
+        }
+
+        comp = CONTAINING_RECORD(This->position, struct cifcomponent, entry);
+    } while (This->group_id && (!comp->group || strcmp(This->group_id, comp->group)));
+
+    *component = &comp->ICifComponent_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI enum_components_Reset(IEnumCifComponents *iface)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+
+    TRACE("(%p)\n", This);
+
+    This->position = This->start;
+    return S_OK;
+}
+
+static const IEnumCifComponentsVtbl enum_componentsVtbl =
+{
+    enum_components_QueryInterface,
+    enum_components_AddRef,
+    enum_components_Release,
+    enum_components_Next,
+    enum_components_Reset,
+};
+
+static HRESULT enum_components_create(ICifFile *file, struct list *start, char *group_id, IEnumCifComponents **iface)
+{
+    struct ciffenum_components *enumerator;
+
+    enumerator = heap_alloc_zero(sizeof(*enumerator));
+    if (!enumerator) return E_OUTOFMEMORY;
+
+    enumerator->IEnumCifComponents_iface.lpVtbl = &enum_componentsVtbl;
+    enumerator->ref      = 1;
+    enumerator->file     = file;
+    enumerator->start    = start;
+    enumerator->position = start;
+    enumerator->group_id = group_id;
+
+    ICifFile_AddRef(file);
+
+    *iface = &enumerator->IEnumCifComponents_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI enum_groups_QueryInterface(IEnumCifGroups *iface, REFIID riid, void **ppv)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->IEnumCifGroups_iface;
+    }
+    /*
+    else if (IsEqualGUID(&IID_IEnumCifGroups, riid))
+    {
+        TRACE("(%p)->(IID_ICifFile %p)\n", This, ppv);
+        *ppv = &This->IEnumCifGroups_iface;
+    }
+    */
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI enum_groups_AddRef(IEnumCifGroups *iface)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI enum_groups_Release(IEnumCifGroups *iface)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    if(!ref)
+    {
+        ICifFile_Release(This->file);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI enum_groups_Next(IEnumCifGroups *iface, ICifGroup **group)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+    struct cifgroup *gp;
+
+    TRACE("(%p)->(%p)\n", This, group);
+
+    if (!This->position || !group)
+        return E_FAIL;
+
+    This->position = list_next(This->start, This->position);
+
+    if (!This->position)
+        return E_FAIL;
+
+    gp = CONTAINING_RECORD(This->position, struct cifgroup, entry);
+    *group = &gp->ICifGroup_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI enum_groups_Reset(IEnumCifGroups *iface)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+
+    TRACE("(%p)\n", This);
+
+    This->position = This->start;
+    return S_OK;
+}
+
+static const IEnumCifGroupsVtbl enum_groupsVtbl =
+{
+    enum_groups_QueryInterface,
+    enum_groups_AddRef,
+    enum_groups_Release,
+    enum_groups_Next,
+    enum_groups_Reset,
+};
+
+static HRESULT enum_groups_create(ICifFile *file, struct list *start, IEnumCifGroups **iface)
+{
+    struct ciffenum_groups *enumerator;
+
+    enumerator = heap_alloc_zero(sizeof(*enumerator));
+    if (!enumerator) return E_OUTOFMEMORY;
+
+    enumerator->IEnumCifGroups_iface.lpVtbl = &enum_groupsVtbl;
+    enumerator->ref      = 1;
+    enumerator->file     = file;
+    enumerator->start    = start;
+    enumerator->position = start;
+
+    ICifFile_AddRef(file);
+
+    *iface = &enumerator->IEnumCifGroups_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI ciffile_QueryInterface(ICifFile *iface, REFIID riid, void **ppv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->ICifFile_iface;
+    }
+    else if (IsEqualGUID(&IID_ICifFile, riid))
+    {
+        TRACE("(%p)->(IID_ICifFile %p)\n", This, ppv);
+        *ppv = &This->ICifFile_iface;
+    }
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI ciffile_AddRef(ICifFile *iface)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI ciffile_Release(ICifFile *iface)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    if(!ref)
+    {
+        struct cifcomponent *comp, *comp_next;
+        struct cifgroup *group, *group_next;
+
+        heap_free(This->name);
+
+        LIST_FOR_EACH_ENTRY_SAFE(comp, comp_next, &This->components, struct cifcomponent, entry)
+        {
+            list_remove(&comp->entry);
+            component_free(comp);
+        }
+
+        LIST_FOR_EACH_ENTRY_SAFE(group, group_next, &This->groups, struct cifgroup, entry)
+        {
+            list_remove(&group->entry);
+            group_free(group);
+        }
+
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI ciffile_EnumComponents(ICifFile *iface, IEnumCifComponents **enum_components, DWORD filter, void *pv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    TRACE("(%p)->(%p, %u, %p)\n", This, enum_components, filter, pv);
+
+    if (filter)
+        FIXME("filter (%x) not supported\n", filter);
+    if (pv)
+        FIXME("how to handle pv (%p)?\n", pv);
+
+    return enum_components_create(iface, &This->components, NULL, enum_components);
+}
+
+static HRESULT WINAPI ciffile_FindComponent(ICifFile *iface, const char *id, ICifComponent **component)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    struct cifcomponent *comp;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_a(id), component);
+
+    LIST_FOR_EACH_ENTRY(comp, &This->components, struct cifcomponent, entry)
+    {
+        if (strcmp(comp->id, id) != 0)
+            continue;
+
+        *component = &comp->ICifComponent_iface;
+        return S_OK;
+    }
+
+    return E_FAIL;
+}
+
+static HRESULT WINAPI ciffile_EnumGroups(ICifFile *iface, IEnumCifGroups **enum_groups, DWORD filter, void *pv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    TRACE("(%p)->(%p, %u, %p)\n", This, enum_groups, filter, pv);
+
+    if (filter)
+        FIXME("filter (%x) not supported\n", filter);
+    if (pv)
+        FIXME("how to handle pv (%p)?\n", pv);
+
+    return enum_groups_create(iface, &This->groups, enum_groups);
+}
+
+static HRESULT WINAPI ciffile_FindGroup(ICifFile *iface, const char *id, ICifGroup **group)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    struct cifgroup *gp;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_a(id), group);
+
+    LIST_FOR_EACH_ENTRY(gp, &This->groups, struct cifgroup, entry)
+    {
+        if (strcmp(gp->id, id) != 0)
+            continue;
+
+        *group = &gp->ICifGroup_iface;
+        return S_OK;
+    }
+
+    return E_FAIL;
+}
+
+static HRESULT WINAPI ciffile_EnumModes(ICifFile *iface, IEnumCifModes **cuf_modes, DWORD filter, void *pv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    FIXME("(%p)->(%p, %u, %p): stub\n", This, cuf_modes, filter, pv);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ciffile_FindMode(ICifFile *iface, const char *id, ICifMode **mode)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    FIXME("(%p)->(%s, %p): stub\n", This, debugstr_a(id), mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ciffile_GetDescription(ICifFile *iface, char *desc, DWORD size)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    TRACE("(%p)->(%p, %u)\n", This, desc, size);
+
+    return copy_substring_null(desc, size, This->name);
+}
+
+static HRESULT WINAPI ciffile_GetDetDlls(ICifFile *iface, char *dlls, DWORD size)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    FIXME("(%p)->(%p, %u): stub\n", This, dlls, size);
+
+    return E_NOTIMPL;
+}
+
+static const ICifFileVtbl ciffileVtbl =
+{
+    ciffile_QueryInterface,
+    ciffile_AddRef,
+    ciffile_Release,
+    ciffile_EnumComponents,
+    ciffile_FindComponent,
+    ciffile_EnumGroups,
+    ciffile_FindGroup,
+    ciffile_EnumModes,
+    ciffile_FindMode,
+    ciffile_GetDescription,
+    ciffile_GetDetDlls,
+};
+
+static BOOL copy_string(char **dest, const char *source)
+{
+    if (!source)
+    {
+        *dest = NULL;
+        return TRUE;
+    }
+
+    *dest = strdupA(source);
+    if (!dest) return FALSE;
+    return TRUE;
+}
+
+static BOOL section_get_str(struct inf_section *inf_sec, const char *key, char **value, const char *def)
+{
+    struct inf_value *inf_val;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val) return copy_string(value, def);
+
+    *value = inf_value_get_value(inf_val);
+    if (!*value) return FALSE;
+
+    return TRUE;
+}
+
+static char *next_part(char **str, BOOL strip_quotes)
+{
+    char *start = *str;
+    char *next = *str;
+
+    while (*next && *next != ',')
+        next++;
+
+    if (!*next)
+    {
+        *str = trim(start, NULL, strip_quotes);
+        return NULL;
+    }
+
+    *next = 0;
+    *str = trim(start, NULL, strip_quotes);
+    return ++next;
+}
+
+static BOOL value_get_str_field(struct inf_value *inf_val, int field, char **value, const char *def)
+{
+    char *line, *str, *next;
+    int i = 0;
+
+    line = inf_value_get_value(inf_val);
+    if (!line) return FALSE;
+
+    str = line;
+    do
+    {
+        i++;
+        next = next_part(&str, TRUE);
+
+        if (field == i)
+        {
+            BOOL ret = copy_string(value, str);
+            heap_free(line);
+            return ret;
+        }
+
+        str = next;
+    } while (str);
+
+    return copy_string(value, def);
+}
+
+/*
+static BOOL section_get_str_field(struct inf_section *inf_sec, const char *key, int field, char **value, const char *def)
+{
+    struct inf_value *inf_val;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val) return copy_string(value, def);
+
+    return value_get_str_field(inf_val, field, value, def);
+}
+*/
+
+static BOOL section_get_dword(struct inf_section *inf_sec, const char *key, DWORD *value, DWORD def)
+{
+    struct inf_value *inf_val;
+    char *str;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val)
+    {
+        *value = def;
+        return TRUE;
+    }
+
+    str = inf_value_get_value(inf_val);
+    if (!str) return FALSE;
+
+    *value = atoi(str);
+    heap_free(str);
+
+    return TRUE;
+}
+
+static BOOL value_get_dword_field(struct inf_value *inf_val, int field, DWORD *value, DWORD def)
+{
+    char *value_str;
+    BOOL ret;
+
+    ret = value_get_str_field(inf_val, field, &value_str, NULL);
+    if (!ret) return FALSE;
+    if (!value_str)
+    {
+        *value = def;
+        return TRUE;
+    }
+
+    *value = atoi(value_str);
+    heap_free(value_str);
+
+    return TRUE;
+}
+
+static BOOL section_get_dword_field(struct inf_section *inf_sec, const char *key, int field, DWORD *value, DWORD def)
+{
+    struct inf_value *inf_val;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val)
+    {
+        *value = def;
+        return TRUE;
+    }
+
+    return value_get_dword_field(inf_val, field, value, def);
+}
+
+static HRESULT process_version(struct ciffile *file, struct inf_section *section)
+{
+    if (!section_get_str(section, "DisplayName", &file->name, DEFAULT_INSTALLER_DESC))
+        return E_OUTOFMEMORY;
+
+    return S_OK;
+}
+
+static BOOL read_version_entry(struct inf_section *section, DWORD *ret_ver, DWORD *ret_build)
+{
+    DWORD version = 0;
+    DWORD build = 0;
+    char *line, *str, *next;
+
+    if (!section_get_str(section, "Version", &line, NULL))
+        return FALSE;
+    if (!line) goto done;
+
+    str = line;
+
+    next = next_part(&str, TRUE);
+    version |= atoi(str) << 16;
+    if (!next) goto done;
+    str = next;
+
+    next = next_part(&str, TRUE);
+    version |= atoi(str) & 0xffff;
+    if (!next) goto done;
+    str = next;
+
+    next = next_part(&str, TRUE);
+    build |= atoi(str) << 16;
+    if (!next) goto done;
+    str = next;
+
+    next_part(&str, TRUE);
+    build |= atoi(str) & 0xffff;
+
+done:
+    heap_free(line);
+    *ret_ver = version;
+    *ret_build = build;
+    return TRUE;
+}
+
+static BOOL read_platform_entry(struct inf_section *section, DWORD *ret_platform)
+{
+    DWORD platform = PLATFORM_ALL;
+    char *line, *str, *next;
+
+    if (!section_get_str(section, "Platform", &line, NULL))
+        return FALSE;
+    if (!line) goto done;
+
+    platform = 0;
+    str = line;
+    do
+    {
+        next = next_part(&str, TRUE);
+
+        if (strcasecmp(str, "Win95") == 0)
+            platform |= PLATFORM_WIN98;
+        else if (strcasecmp(str, "Win98") == 0)
+            platform |= PLATFORM_WIN98;
+        else if (strcasecmp(str, "NT4") == 0)
+            platform |= PLATFORM_NT4;
+        else if (strcasecmp(str, "NT5") == 0)
+            platform |= PLATFORM_NT5;
+        else if (strcasecmp(str, "NT4Alpha") == 0)
+            platform |= PLATFORM_NT4;
+        else if (strcasecmp(str, "NT5Alpha") == 0)
+            platform |= PLATFORM_NT5;
+        else if (strcasecmp(str, "Millen") == 0)
+            platform |= PLATFORM_MILLEN;
+        else
+            FIXME("Unknown platform: %s\n", debugstr_a(str));
+
+        str = next;
+    } while (str);
+
+done:
+    heap_free(line);
+    *ret_platform = platform;
+    return TRUE;
+}
+
+static BOOL read_dependencies(struct cifcomponent *component, struct inf_section *section)
+{
+    struct dependency_info *dependency;
+    char *line, *str, *next;
+    BOOL ret = TRUE;
+
+    if (!section_get_str(section, "Dependencies", &line, NULL))
+        return E_OUTOFMEMORY;
+    if (!line) goto done;
+
+    ret = FALSE;
+    str = line;
+    do
+    {
+        next = next_part(&str, TRUE);
+
+        dependency = heap_alloc_zero(sizeof(*dependency));
+        if (!dependency) goto done;
+
+        dependency->id = strdupA(str);
+        if (!dependency->id)
+        {
+            heap_free(dependency);
+            goto done;
+        }
+
+        dependency->type = strstr(dependency->id, ":");
+        if (dependency->type) *dependency->type++ = 0;
+
+        list_add_tail(&component->dependencies, &dependency->entry);
+
+        str = next;
+    } while (str);
+
+    ret = TRUE;
+
+done:
+    heap_free(line);
+    return ret;
+}
+
+static BOOL read_urls(struct cifcomponent *component, struct inf_section *section)
+{
+    struct inf_value *inf_value = NULL;
+    struct url_info *url_entry;
+    char *str, *next;
+    int index;
+
+    while (inf_section_next_value(section, &inf_value))
+    {
+        str = inf_value_get_key(inf_value);
+        if (!str) return E_OUTOFMEMORY;
+
+        if (strncasecmp(str, "URL", 3))
+            goto next;
+
+        if (!str[3])
+            goto next;
+
+        index = strtol(str+3, &next, 10);
+        if (next == str+3 || *next != 0 || index < 1)
+            goto next;
+        index--;
+
+        url_entry = heap_alloc_zero(sizeof(*url_entry));
+        if (!url_entry) goto error;
+
+        url_entry->index = index;
+
+        if (!value_get_str_field(inf_value, 1, &url_entry->url, NULL))
+            goto error;
+        if (!url_entry->url || !*url_entry->url)
+        {
+            url_entry_free(url_entry);
+            goto next;
+        }
+
+        if (!value_get_dword_field(inf_value, 2, &url_entry->flags, 0))
+            goto error;
+
+        list_add_tail(&component->urls, &url_entry->entry);
+
+    next:
+        heap_free(str);
+    }
+
+    return TRUE;
+
+error:
+    heap_free(str);
+    url_entry_free(url_entry);
+    return FALSE;
+};
+
+void add_component_by_priority(struct ciffile *file, struct cifcomponent *component)
+{
+    struct cifcomponent *entry;
+
+    LIST_FOR_EACH_ENTRY(entry, &file->components, struct cifcomponent, entry)
+    {
+        if (entry->priority > component->priority)
+            continue;
+
+        list_add_before(&entry->entry, &component->entry);
+        return;
+    }
+
+    list_add_tail(&file->components, &component->entry);
+}
+
+static HRESULT process_component(struct ciffile *file, struct inf_section *section, const char *section_name)
+{
+    struct cifcomponent *component;
+    HRESULT hr = E_OUTOFMEMORY;
+
+    component = heap_alloc_zero(sizeof(*component));
+    if (!component) return E_OUTOFMEMORY;
+
+    component->ICifComponent_iface.lpVtbl = &cifcomponentVtbl;
+    component->parent = &file->ICifFile_iface;
+
+    list_init(&component->urls);
+    list_init(&component->dependencies);
+
+    component->queue_state = ActionNone;
+
+    component->id = strdupA(section_name);
+    if (!component->id) goto error;
+
+    if (!section_get_str(section, "DisplayName", &component->description, NULL))
+        goto error;
+    if (!section_get_str(section, "GUID", &component->guid, NULL))
+        goto error;
+    if (!section_get_str(section, "Details", &component->details, NULL))
+        goto error;
+    if (!section_get_str(section, "Group", &component->group, NULL))
+        goto error;
+    if (!section_get_str(section, "Locale", &component->locale, "en"))
+        goto error;
+    if (!section_get_str(section, "PatchID", &component->patchid, NULL))
+        goto error;
+
+    if (!section_get_dword_field(section, "Size", 1, &component->size_download, 0))
+        goto error;
+    if (!section_get_dword_field(section, "Size", 2, &component->size_extracted, 0))
+        goto error;
+    if (!section_get_dword_field(section, "InstalledSize", 1, &component->size_app, 0))
+        goto error;
+    if (!section_get_dword_field(section, "InstalledSize", 2, &component->size_win, 0))
+        goto error;
+
+    if (!section_get_str(section, "SuccessKey", &component->key_success, NULL))
+        goto error;
+    if (!section_get_str(section, "CancelKey", &component->key_cancel, NULL))
+        goto error;
+    if (!section_get_str(section, "ProgressKey", &component->key_progress, NULL))
+        goto error;
+    if (!section_get_str(section, "UninstallKey", &component->key_uninstall, NULL))
+        goto error;
+    if (!section_get_dword(section, "Reboot", &component->reboot, 0))
+        goto error;
+    if (!section_get_dword(section, "AdminCheck", &component->admin, 0))
+        goto error;
+    if (!section_get_dword(section, "UIVisible", &component->visibleui, 1))
+        goto error;
+    if (!section_get_dword(section, "ActiveSetupAware", &component->as_aware, 0))
+        goto error;
+    if (!section_get_dword(section, "Priority", &component->priority, 0))
+        goto error;
+
+    if (!read_version_entry(section, &component->version, &component->build))
+        goto error;
+    if (!read_platform_entry(section, &component->platform))
+        goto error;
+    if (!read_urls(component, section))
+        goto error;
+    if (!read_dependencies(component, section))
+        goto error;
+
+    component->current_priority = component->priority;
+
+    add_component_by_priority(file, component);
+    return S_OK;
+
+error:
+    component_free(component);
+    return hr;
+}
+
+static HRESULT process_group(struct ciffile *file, struct inf_section *section, const char *section_name)
+{
+    struct cifgroup *group;
+    HRESULT hr = E_OUTOFMEMORY;
+
+    group = heap_alloc_zero(sizeof(*group));
+    if (!group) return E_OUTOFMEMORY;
+
+    group->ICifGroup_iface.lpVtbl = &cifgroupVtbl;
+    group->parent = &file->ICifFile_iface;
+
+    group->id = strdupA(section_name);
+    if (!group->id) goto error;
+
+    if (!section_get_str(section, "DisplayName", &group->description, NULL))
+        goto error;
+    if (!section_get_dword(section, "Priority", &group->priority, 0))
+        goto error;
+
+    list_add_head(&file->groups, &group->entry);
+    return S_OK;
+
+error:
+    group_free(group);
+    return hr;
+}
+
+static HRESULT process_section(struct ciffile *file, struct inf_section *section, const char *section_name)
+{
+    HRESULT hr = S_OK;
+    char *type;
+
+    if (!section_get_str(section, "SectionType", &type, "Component"))
+        return E_OUTOFMEMORY;
+
+    if (!strcasecmp(type, "Component"))
+        hr = process_component(file, section, section_name);
+    else if (strcasecmp(type, "Group") == 0)
+        hr = process_group(file, section, section_name);
+    else
+        FIXME("Don't know how to process %s\n", debugstr_a(type));
+
+    heap_free(type);
+    return hr;
+}
+
+static HRESULT process_inf(struct ciffile *file, struct inf_file *inf)
+{
+    struct inf_section *section = NULL;
+    char *section_name;
+    HRESULT hr = S_OK;
+
+    while (SUCCEEDED(hr) && inf_next_section(inf, &section))
+    {
+        section_name = inf_section_get_name(section);
+        if (!section_name) return E_OUTOFMEMORY;
+
+        TRACE("start processing section %s\n", debugstr_a(section_name));
+
+        if (!strcasecmp(section_name, "Strings") ||
+            !strncasecmp(section_name, "Strings.", strlen("Strings.")))
+        {
+            /* Ignore string sections */
+        }
+        else if (strcasecmp(section_name, "Version") == 0)
+            hr = process_version(file, section);
+        else
+            hr = process_section(file, section, section_name);
+
+        TRACE("finished processing section %s (%x)\n", debugstr_a(section_name), hr);
+        heap_free(section_name);
+    }
+
+    /* In case there was no version section, set the default installer description */
+    if (SUCCEEDED(hr) && !file->name)
+    {
+        file->name = strdupA(DEFAULT_INSTALLER_DESC);
+        if (!file->name) hr = E_OUTOFMEMORY;
+    }
+
+    return hr;
+}
+
+static HRESULT load_ciffile(const char *path, ICifFile **icif)
+{
+    struct inf_file *inf = NULL;
+    struct ciffile *file;
+    HRESULT hr = E_FAIL;
+
+    file = heap_alloc_zero(sizeof(*file));
+    if(!file) return E_OUTOFMEMORY;
+
+    file->ICifFile_iface.lpVtbl = &ciffileVtbl;
+    file->ref = 1;
+
+    list_init(&file->components);
+    list_init(&file->groups);
+
+    hr = inf_load(path, &inf);
+    if (FAILED(hr)) goto error;
+
+    hr = process_inf(file, inf);
+    if (FAILED(hr)) goto error;
+
+    *icif = &file->ICifFile_iface;
+    return S_OK;
+
+error:
+    if (inf) inf_free(inf);
+    ICifFile_Release(&file->ICifFile_iface);
+    return hr;
+}
+
+HRESULT WINAPI GetICifFileFromFile(ICifFile **icif, const char *path)
+{
+    TRACE("(%p, %s)\n", icif, debugstr_a(path));
+
+    return load_ciffile(path, icif);
+}
+
+
+HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **icif, const char *path)
+{
+    FIXME("(%p, %s): stub\n", icif, debugstr_a(path));
+
+    return E_NOTIMPL;
+}
diff --git a/dlls/inseng/inf.c b/dlls/inseng/inf.c
new file mode 100644
index 00000000000..bead72c082c
--- /dev/null
+++ b/dlls/inseng/inf.c
@@ -0,0 +1,443 @@
+/*
+ * Copyright 2016 Michael MÃ¼ller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <string.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+
+#include "inseng_private.h"
+
+#include "wine/list.h"
+
+struct inf_value
+{
+    struct list entry;
+    char *key;
+    char *value;
+
+    struct inf_section *section;
+};
+
+struct inf_section
+{
+    struct list entry;
+    char *name;
+    struct list values;
+
+    struct inf_file *file;
+};
+
+struct inf_file
+{
+    char *content;
+    DWORD size;
+    struct list sections;
+};
+
+static void inf_value_free(struct inf_value *value)
+{
+    heap_free(value);
+}
+
+static void inf_section_free(struct inf_section *section)
+{
+    struct inf_value *val, *val_next;
+    LIST_FOR_EACH_ENTRY_SAFE(val, val_next, &section->values, struct inf_value, entry)
+    {
+        list_remove(&val->entry);
+        inf_value_free(val);
+    }
+
+    heap_free(section);
+}
+
+static const char *get_substitution(struct inf_file *inf, const char *name, int len)
+{
+    struct inf_section *sec;
+    struct inf_value *value = NULL;
+
+    sec = inf_get_section(inf, "Strings");
+    if (!sec) return NULL;
+
+    while (inf_section_next_value(sec, &value))
+    {
+        if (strlen(value->key) == len && !strncasecmp(value->key, name, len))
+            return value->value;
+    }
+
+    return NULL;
+}
+
+static int expand_variables_buffer(struct inf_file *inf, const char *str, char *output)
+{
+    const char *p, *var_start = NULL;
+    int var_len = 0, len = 0;
+    const char *substitution;
+
+    for (p = str; *p; p++)
+    {
+        if (*p != '%')
+        {
+            if (var_start)
+                var_len++;
+            else
+            {
+                if (output)
+                    *output++ = *p;
+                len++;
+            }
+
+            continue;
+        }
+
+        if (!var_start)
+        {
+            var_start = p;
+            var_len = 0;
+
+            continue;
+        }
+
+        if (!var_len)
+        {
+            /* just an escaped % */
+            if (output)
+                *output++ = '%';
+            len += 1;
+
+            var_start = NULL;
+            continue;
+        }
+
+        substitution = get_substitution(inf, var_start + 1, var_len);
+        if (!substitution)
+        {
+            if (output)
+            {
+                memcpy(output, var_start, var_len + 2);
+                output += var_len + 2;
+            }
+            len += var_len + 2;
+        }
+        else
+        {
+            int sub_len = strlen(substitution);
+
+            if (output)
+            {
+                memcpy(output, substitution, sub_len);
+                output += sub_len;
+            }
+            len += sub_len;
+        }
+
+         var_start = NULL;
+    }
+
+    if (output) *output = 0;
+    return len + 1;
+}
+
+static char *expand_variables(struct inf_file *inf, const char *str)
+{
+    char *buffer;
+    int len;
+
+    len = expand_variables_buffer(inf, str, NULL);
+    buffer = heap_alloc(len);
+    if (!len) return NULL;
+
+    expand_variables_buffer(inf, str, buffer);
+    return buffer;
+}
+
+void inf_free(struct inf_file *inf)
+{
+    struct inf_section *sec, *sec_next;
+    LIST_FOR_EACH_ENTRY_SAFE(sec, sec_next, &inf->sections, struct inf_section, entry)
+    {
+        list_remove(&sec->entry);
+        inf_section_free(sec);
+    }
+
+    heap_free(inf->content);
+    heap_free(inf);
+}
+
+BOOL inf_next_section(struct inf_file *inf, struct inf_section **sec)
+{
+    struct list *next_entry, *cur_position;
+
+    if (*sec)
+        cur_position = &(*sec)->entry;
+    else
+        cur_position = &inf->sections;
+
+    next_entry = list_next(&inf->sections, cur_position);
+    if (!next_entry) return FALSE;
+
+    *sec = CONTAINING_RECORD(next_entry, struct inf_section, entry);
+    return TRUE;
+}
+
+struct inf_section *inf_get_section(struct inf_file *inf, const char *name)
+{
+    struct inf_section *sec = NULL;
+
+    while (inf_next_section(inf, &sec))
+    {
+        if (!strcasecmp(sec->name, name))
+            return sec;
+    }
+
+    return NULL;
+}
+
+char *inf_section_get_name(struct inf_section *section)
+{
+    return strdupA(section->name);
+}
+
+BOOL inf_section_next_value(struct inf_section *sec, struct inf_value **value)
+{
+    struct list *next_entry, *cur_position;
+
+    if (*value)
+        cur_position = &(*value)->entry;
+    else
+        cur_position = &sec->values;
+
+    next_entry = list_next(&sec->values, cur_position);
+    if (!next_entry) return FALSE;
+
+    *value = CONTAINING_RECORD(next_entry, struct inf_value, entry);
+    return TRUE;
+}
+
+struct inf_value *inf_get_value(struct inf_section *sec, const char *key)
+{
+    struct inf_value *value = NULL;
+
+    while (inf_section_next_value(sec, &value))
+    {
+        if (!strcasecmp(value->key, key))
+            return value;
+    }
+
+    return NULL;
+}
+
+char *inf_value_get_key(struct inf_value *value)
+{
+    return strdupA(value->key);
+}
+
+char *inf_value_get_value(struct inf_value *value)
+{
+    return expand_variables(value->section->file, value->value);
+}
+
+char *trim(char *str, char **last_chr, BOOL strip_quotes)
+{
+    char *last;
+
+    for (; *str; str++)
+    {
+        if (*str != '\t' && *str != ' ')
+            break;
+    }
+
+    if (!*str)
+    {
+        if (last_chr) *last_chr = str;
+        return str;
+    }
+
+    last = str + strlen(str) - 1;
+
+    for (; last > str; last--)
+    {
+        if (*last != '\t' && *last != ' ')
+            break;
+        *last = 0;
+    }
+
+    if (strip_quotes && last != str)
+    {
+        if (*last == '"' && *str == '"')
+        {
+            str++;
+            *last = 0;
+        }
+    }
+
+    if (last_chr) *last_chr = last;
+    return str;
+}
+
+static char *get_next_line(char **str, char **last_chr)
+{
+    BOOL in_next_line = FALSE;
+    char *start, *next;
+
+    start = *str;
+    if (!start || !*start) return NULL;
+
+    for (next = start; *next; next++)
+    {
+        if (*next == '\n' || *next == '\r')
+        {
+            *next = 0;
+            in_next_line = TRUE;
+        }
+        else if (in_next_line)
+        {
+            break;
+        }
+    }
+
+    *str = next;
+    return trim(start, last_chr, FALSE);
+}
+
+/* This function only fails in case of an memory allocation error
+ * and does not touch section in case the parsing failed. */
+static HRESULT inf_section_parse(struct inf_file *inf, char *line, char *last_chr, struct inf_section **section)
+{
+    struct inf_section *sec;
+    char *comment;
+    char *name;
+
+    if (*line != '[')
+        return S_OK;
+
+    line++;
+
+    comment = strchr(line, ';');
+    if (comment)
+    {
+        *comment = 0;
+        line = trim(line, &last_chr, FALSE);
+    }
+
+    if (*last_chr != ']')
+        return S_OK;
+
+    *last_chr = 0;
+    name = trim(line, NULL, FALSE);
+    if (!name) return S_OK;
+
+    sec = heap_alloc_zero(sizeof(*sec));
+    if (!sec) return E_OUTOFMEMORY;
+
+    sec->name = name;
+    sec->file = inf;
+    list_init(&sec->values);
+
+    list_add_tail(&inf->sections, &sec->entry);
+
+    *section = sec;
+    return S_OK;
+}
+
+static HRESULT inf_value_parse(struct inf_section *sec, char *line)
+{
+    struct inf_value *key_val;
+    char *key, *value, *del;
+
+    del = strchr(line, '=');
+    if (!del) return S_OK;
+
+    *del = 0;
+    key = line;
+    value = del + 1;
+
+    key = trim(key, NULL, FALSE);
+    value = trim(value, NULL, TRUE);
+
+    key_val = heap_alloc_zero(sizeof(*key_val));
+    if (!key_val) return E_OUTOFMEMORY;
+
+    key_val->key = key;
+    key_val->value = value;
+    key_val->section = sec;
+
+    list_add_tail(&sec->values, &key_val->entry);
+    return S_OK;
+}
+
+static HRESULT inf_process_content(struct inf_file *inf)
+{
+    struct inf_section *section = NULL;
+    char *content = inf->content;
+    char *line, *last_chr;
+    HRESULT hr = S_OK;
+
+    while (SUCCEEDED(hr) && (line = get_next_line(&content, &last_chr)))
+    {
+        if (*line == '[')
+            hr = inf_section_parse(inf, line, last_chr, &section);
+        else if (strchr(line, '=') && section)
+            hr = inf_value_parse(section, line);
+    }
+
+    return hr;
+}
+
+HRESULT inf_load(const char *path, struct inf_file **inf_file)
+{
+    LARGE_INTEGER file_size;
+    struct inf_file *inf;
+    HRESULT hr = E_FAIL;
+    HANDLE file;
+    DWORD read;
+
+    file = CreateFileA(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (file == INVALID_HANDLE_VALUE) return E_FAIL;
+
+    inf = heap_alloc_zero(sizeof(*inf));
+    if (!inf) goto error;
+
+    if (!GetFileSizeEx(file, &file_size))
+        goto error;
+
+    inf->size = file_size.QuadPart;
+
+    inf->content = heap_alloc_zero(inf->size);
+    if (!inf->content) goto error;
+
+    list_init(&inf->sections);
+
+    if (!ReadFile(file, inf->content, inf->size, &read, NULL) || read != inf->size)
+        goto error;
+
+    hr = inf_process_content(inf);
+    if (FAILED(hr)) goto error;
+
+    CloseHandle(file);
+    *inf_file = inf;
+    return S_OK;
+
+error:
+    if (inf) inf_free(inf);
+    CloseHandle(file);
+    return hr;
+}
diff --git a/dlls/inseng/inseng.spec b/dlls/inseng/inseng.spec
index 82c0b4d5fe1..7ae46fad3a7 100644
--- a/dlls/inseng/inseng.spec
+++ b/dlls/inseng/inseng.spec
@@ -7,6 +7,6 @@
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
 @ stub DownloadFile
-@ stub GetICifFileFromFile
-@ stub GetICifRWFileFromFile
+@ stdcall GetICifFileFromFile(ptr str)
+@ stdcall GetICifRWFileFromFile(ptr str)
 @ stub PurgeDownloadDirectory
diff --git a/dlls/inseng/inseng_main.c b/dlls/inseng/inseng_main.c
index 2c95a2e72bd..6a926ccb379 100644
--- a/dlls/inseng/inseng_main.c
+++ b/dlls/inseng/inseng_main.c
@@ -2,6 +2,7 @@
  *    INSENG Implementation
  *
  * Copyright 2006 Mike McCormack
+ * Copyright 2016 Michael MÃ¼ller
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -28,17 +29,68 @@
 #include "winuser.h"
 #include "ole2.h"
 #include "rpcproxy.h"
+#include "urlmon.h"
+#include "shlwapi.h"
 #include "initguid.h"
 #include "inseng.h"
 
+#include "inseng_private.h"
+
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(inseng);
 
+enum thread_operation
+{
+    OP_DOWNLOAD,
+    OP_INSTALL
+};
+
+struct thread_info
+{
+    DWORD operation;
+    DWORD jobflags;
+    IEnumCifComponents *enum_comp;
+
+    DWORD download_size;
+    DWORD install_size;
+
+    DWORD downloaded_kb;
+    ULONGLONG download_start;
+};
+
 struct InstallEngine {
     IInstallEngine2 IInstallEngine2_iface;
+    IInstallEngineTiming IInstallEngineTiming_iface;
     LONG ref;
+
+    IInstallEngineCallback *callback;
+    char *baseurl;
+    char *downloaddir;
+    ICifFile *icif;
+    DWORD status;
+
+    /* used for the installation thread */
+    struct thread_info thread;
+};
+
+struct downloadcb
+{
+    IBindStatusCallback IBindStatusCallback_iface;
+    LONG ref;
+
+    WCHAR *file_name;
+    WCHAR *cache_file;
+
+    char *id;
+    char *display;
+
+    DWORD dl_size;
+    DWORD dl_previous_kb;
+
+    InstallEngine *engine;
+    HANDLE event_done;
+    HRESULT hr;
 };
 
 static inline InstallEngine *impl_from_IInstallEngine2(IInstallEngine2 *iface)
@@ -46,6 +98,250 @@ static inline InstallEngine *impl_from_IInstallEngine2(IInstallEngine2 *iface)
     return CONTAINING_RECORD(iface, InstallEngine, IInstallEngine2_iface);
 }
 
+static inline struct downloadcb *impl_from_IBindStatusCallback(IBindStatusCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct downloadcb, IBindStatusCallback_iface);
+}
+
+static inline InstallEngine *impl_from_IInstallEngineTiming(IInstallEngineTiming *iface)
+{
+    return CONTAINING_RECORD(iface, InstallEngine, IInstallEngineTiming_iface);
+}
+
+static HRESULT WINAPI downloadcb_QueryInterface(IBindStatusCallback *iface, REFIID riid, void **ppv)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->IBindStatusCallback_iface;
+    }
+    else if (IsEqualGUID(&IID_IBindStatusCallback, riid))
+    {
+        TRACE("(%p)->(IID_IBindStatusCallback %p)\n", This, ppv);
+        *ppv = &This->IBindStatusCallback_iface;
+    }
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI downloadcb_AddRef(IBindStatusCallback *iface)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref = %d\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI downloadcb_Release(IBindStatusCallback *iface)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref = %d\n", This, ref);
+
+    if (!ref)
+    {
+        heap_free(This->file_name);
+        heap_free(This->cache_file);
+
+        IInstallEngine2_Release(&This->engine->IInstallEngine2_iface);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI downloadcb_OnStartBinding(IBindStatusCallback *iface, DWORD reserved, IBinding *pbind)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%u %p)\n", This, reserved, pbind);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_GetPriority(IBindStatusCallback *iface, LONG *priority)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%p): stub\n", This, priority);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI downloadcb_OnLowResource(IBindStatusCallback *iface, DWORD reserved)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%u): stub\n", This, reserved);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI downloadcb_OnProgress(IBindStatusCallback *iface, ULONG progress,
+        ULONG progress_max, ULONG status, const WCHAR *status_text)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("%p)->(%u %u %u %s)\n", This, progress, progress_max, status, debugstr_w(status_text));
+
+    switch(status)
+    {
+        case BINDSTATUS_BEGINDOWNLOADDATA:
+            if (!This->engine->thread.download_start)
+                This->engine->thread.download_start = GetTickCount64();
+            /* fall-through */
+        case BINDSTATUS_DOWNLOADINGDATA:
+        case BINDSTATUS_ENDDOWNLOADDATA:
+            This->engine->thread.downloaded_kb = This->dl_previous_kb + progress / 1024;
+            if (This->engine->callback)
+            {
+                hr = IInstallEngineCallback_OnComponentProgress(This->engine->callback,
+                         This->id, INSTALLSTATUS_DOWNLOADING, This->display, NULL, progress / 1024, This->dl_size);
+            }
+            break;
+
+        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
+            This->cache_file = strdupW(status_text);
+            if (!This->cache_file)
+            {
+                ERR("Failed to allocate memory for cache file\n");
+                hr = E_OUTOFMEMORY;
+            }
+            break;
+
+        case BINDSTATUS_CONNECTING:
+        case BINDSTATUS_SENDINGREQUEST:
+        case BINDSTATUS_MIMETYPEAVAILABLE:
+        case BINDSTATUS_FINDINGRESOURCE:
+            break;
+
+        default:
+            FIXME("Unsupported status %u\n", status);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI downloadcb_OnStopBinding(IBindStatusCallback *iface, HRESULT hresult, LPCWSTR szError)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%08x %s)\n", This, hresult, debugstr_w(szError));
+
+    if (FAILED(hresult))
+    {
+        This->hr = hresult;
+        goto done;
+    }
+
+    if (!This->cache_file)
+    {
+        This->hr = E_FAIL;
+        goto done;
+    }
+
+    if (CopyFileW(This->cache_file, This->file_name, FALSE))
+        This->hr = S_OK;
+    else
+    {
+        ERR("CopyFile failed: %u\n", GetLastError());
+        This->hr = E_FAIL;
+    }
+
+done:
+    SetEvent(This->event_done);
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_GetBindInfo(IBindStatusCallback *iface,
+        DWORD *grfBINDF, BINDINFO *pbindinfo)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%p %p)\n", This, grfBINDF, pbindinfo);
+
+    *grfBINDF = BINDF_PULLDATA | BINDF_NEEDFILE;
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_OnDataAvailable(IBindStatusCallback *iface,
+        DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%08x %u %p %p)\n", This, grfBSCF, dwSize, pformatetc, pstgmed);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_OnObjectAvailable(IBindStatusCallback *iface,
+        REFIID riid, IUnknown *punk)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_guid(riid), punk);
+
+    return E_NOTIMPL;
+}
+
+static const IBindStatusCallbackVtbl BindStatusCallbackVtbl =
+{
+    downloadcb_QueryInterface,
+    downloadcb_AddRef,
+    downloadcb_Release,
+    downloadcb_OnStartBinding,
+    downloadcb_GetPriority,
+    downloadcb_OnLowResource,
+    downloadcb_OnProgress,
+    downloadcb_OnStopBinding,
+    downloadcb_GetBindInfo,
+    downloadcb_OnDataAvailable,
+    downloadcb_OnObjectAvailable
+};
+
+static HRESULT downloadcb_create(InstallEngine *engine, HANDLE event, char *file_name, char *id,
+                                 char *display, DWORD dl_size, struct downloadcb **callback)
+{
+    struct downloadcb *cb;
+
+    cb = heap_alloc_zero(sizeof(*cb));
+    if (!cb) return E_OUTOFMEMORY;
+
+    cb->IBindStatusCallback_iface.lpVtbl = &BindStatusCallbackVtbl;
+    cb->ref = 1;
+    cb->hr = E_FAIL;
+    cb->id = id;
+    cb->display = display;
+    cb->engine = engine;
+    cb->dl_size = dl_size;
+    cb->dl_previous_kb = engine->thread.downloaded_kb;
+    cb->event_done = event;
+    cb->file_name = strAtoW(file_name);
+    if (!cb->file_name)
+    {
+        heap_free(cb);
+        return E_OUTOFMEMORY;
+    }
+
+    IInstallEngine2_AddRef(&engine->IInstallEngine2_iface);
+
+    *callback = cb;
+    return S_OK;
+}
+
 static HRESULT WINAPI InstallEngine_QueryInterface(IInstallEngine2 *iface, REFIID riid, void **ppv)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
@@ -59,13 +355,16 @@ static HRESULT WINAPI InstallEngine_QueryInterface(IInstallEngine2 *iface, REFII
     }else if(IsEqualGUID(&IID_IInstallEngine2, riid)) {
         TRACE("(%p)->(IID_IInstallEngine2 %p)\n", This, ppv);
         *ppv = &This->IInstallEngine2_iface;
+    }else if(IsEqualGUID(&IID_IInstallEngineTiming, riid)) {
+        TRACE("(%p)->(IID_IInstallEngineTiming %p)\n", This, ppv);
+        *ppv = &This->IInstallEngineTiming_iface;
     }else {
-        TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), ppv);
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
         *ppv = NULL;
         return E_NOINTERFACE;
     }
 
-    IUnknown_AddRef((IUnknown*)*ppv);
+    IUnknown_AddRef((IUnknown *)*ppv);
     return S_OK;
 }
 
@@ -86,181 +385,726 @@ static ULONG WINAPI InstallEngine_Release(IInstallEngine2 *iface)
 
     TRACE("(%p) ref=%d\n", This, ref);
 
-    if(!ref)
+    if (!ref)
+    {
+        if (This->icif)
+            ICifFile_Release(This->icif);
+
+        heap_free(This->baseurl);
+        heap_free(This->downloaddir);
         heap_free(This);
+    }
 
     return ref;
 }
 
+static void set_status(InstallEngine *This, DWORD status)
+{
+    This->status = status;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, status, 0);
+}
+
+static HRESULT calc_sizes(IEnumCifComponents *enum_comp, DWORD operation, DWORD *size_download, DWORD *size_install)
+{
+    ICifComponent *comp;
+    DWORD download = 0;
+    DWORD install = 0;
+    HRESULT hr;
+
+    /* FIXME: what about inactive dependencies and how does
+     * INSTALLOPTIONS_FORCEDEPENDENCIES play into this ?*/
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) == S_FALSE)
+            download = ICifComponent_GetDownloadSize(comp);
+        /*
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) == S_FALSE)
+            install = ICifComponent_GetInstalledSize(comp);
+        */
+    }
+
+    *size_download = download;
+    *size_install = install;
+
+    return S_OK;
+}
+
+static HRESULT get_next_component(IEnumCifComponents *enum_comp, DWORD operation, ICifComponent **ret_comp)
+{
+    ICifComponent *comp;
+    HRESULT hr;
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) != S_FALSE)
+            continue;
+
+        *ret_comp = comp;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT get_url(ICifComponent *comp, int index, char **url, DWORD *flags)
+{
+    char *url_temp = NULL;
+    int size = MAX_PATH / 2;
+    HRESULT hr;
+
+    /* FIXME: should we add an internal get function to prevent this ugly code ? */
+
+    /* check if there is an url with such an index */
+    hr = ICifComponent_GetUrl(comp, index, NULL, 0, flags);
+    if (FAILED(hr))
+    {
+        *url = NULL;
+        *flags = 0;
+        return S_OK;
+    }
+
+    do
+    {
+        size *= 2;
+        heap_free(url_temp);
+        url_temp = heap_alloc(size);
+        if (!url_temp) return E_OUTOFMEMORY;
+
+        hr = ICifComponent_GetUrl(comp, index, url_temp, size, flags);
+        if (FAILED(hr))
+        {
+            heap_free(url_temp);
+            return hr;
+        }
+    }
+    while (strlen(url_temp) == size-1);
+
+    *url = url_temp;
+    return S_OK;
+}
+
+static char *combine_url(char *baseurl, char *url)
+{
+    int len_base = strlen(baseurl);
+    int len_url = strlen(url);
+    char *combined;
+
+    combined = heap_alloc(len_base + len_url + 2);
+    if (!combined) return NULL;
+
+    strcpy(combined, baseurl);
+    if (len_base && combined[len_base-1] != '/')
+        strcat(combined, "/");
+    strcat(combined, url);
+
+    return combined;
+}
+
+static HRESULT generate_moniker(char *baseurl, char *url, DWORD flags, IMoniker **moniker)
+{
+    WCHAR *urlW;
+    HRESULT hr;
+
+    if (flags & URLF_RELATIVEURL)
+    {
+        char *combined;
+        if (!baseurl)
+            return E_FAIL;
+
+        combined = combine_url(baseurl, url);
+        if (!combined) return E_OUTOFMEMORY;
+
+        urlW = strAtoW(combined);
+        heap_free(combined);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+    else
+    {
+        urlW = strAtoW(url);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+
+    hr = CreateURLMoniker(NULL, urlW, moniker);
+    heap_free(urlW);
+    return hr;
+}
+
+static char *merge_path(char *path1, char *path2)
+{
+    int len = strlen(path1) + strlen(path2) + 2;
+    char *combined = heap_alloc(len);
+
+    if (!combined) return NULL;
+    strcpy(combined, path1);
+    strcat(combined, "\\");
+    strcat(combined, path2);
+
+    return combined;
+}
+
+static HRESULT download_url(InstallEngine *This, char *id, char *display, char *url, DWORD flags, DWORD dl_size)
+{
+    struct downloadcb *callback = NULL;
+    char *filename    = NULL;
+    IUnknown *unk     = NULL;
+    IMoniker *mon     = NULL;
+    IBindCtx *bindctx = NULL;
+    HANDLE event      = NULL;
+    HRESULT hr;
+
+    if (!This->downloaddir)
+    {
+        WARN("No download directory set\n");
+        return E_FAIL;
+    }
+
+    hr = generate_moniker(This->baseurl, url, flags, &mon);
+    if (FAILED(hr))
+    {
+        FIXME("Failed to create moniker\n");
+        return hr;
+    }
+
+    event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!event)
+    {
+        IMoniker_Release(mon);
+        return E_FAIL;
+    }
+
+    filename = strrchr(url, '/');
+    if (!filename) filename = url;
+
+    filename = merge_path(This->downloaddir, filename);
+    if (!filename)
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+
+    hr = downloadcb_create(This, event, filename, id, display, dl_size, &callback);
+    if (FAILED(hr)) goto error;
+
+    hr = CreateAsyncBindCtx(0, &callback->IBindStatusCallback_iface, NULL, &bindctx);
+    if(FAILED(hr)) goto error;
+
+    hr = IMoniker_BindToStorage(mon, bindctx, NULL, &IID_IUnknown, (void**)&unk);
+    if (FAILED(hr)) goto error;
+    if (unk) IUnknown_Release(unk);
+
+    heap_free(filename);
+    IMoniker_Release(mon);
+    IBindCtx_Release(bindctx);
+
+    WaitForSingleObject(event, INFINITE);
+    hr = callback->hr;
+
+    CloseHandle(event);
+    IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    return hr;
+
+error:
+    if (mon) IMoniker_Release(mon);
+    if (event) CloseHandle(event);
+    if (callback) IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    if (bindctx) IBindCtx_Release(bindctx);
+    if (filename) heap_free(filename);
+    return hr;
+}
+
+static HRESULT process_component_dependencies(InstallEngine *This, ICifComponent *comp)
+{
+    char id[MAX_ID_LENGTH+1], type;
+    DWORD ver, build;
+    HRESULT hr;
+    int i;
+
+    for (i = 0;; i++)
+    {
+        hr = ICifComponent_GetDependency(comp, i, id, sizeof(id), &type, &ver, &build);
+        if (SUCCEEDED(hr))
+            FIXME("Can't handle dependencies yet: %s\n", debugstr_a(id));
+        else
+            break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT process_component(InstallEngine *This, ICifComponent *comp)
+{
+    DWORD size_dl, size_install, phase;
+    char display[MAX_DISPLAYNAME_LENGTH+1];
+    char id[MAX_ID_LENGTH+1];
+    HRESULT hr;
+    int i;
+
+    hr = ICifComponent_GetID(comp, id, sizeof(id));
+    if (FAILED(hr)) return hr;
+
+    TRACE("processing component %s\n", debugstr_a(id));
+
+    hr = ICifComponent_GetDescription(comp, display, sizeof(display));
+    if (FAILED(hr)) return hr;
+
+    size_dl      = (This->thread.operation == OP_DOWNLOAD) ? ICifComponent_GetDownloadSize(comp) : 0;
+    size_install = 0; /* (This->thread.operation == OP_INSTALL) ? ICifComponent_GetInstalledSize(comp) : 0; */
+
+    if (This->callback)
+    {
+        IInstallEngineCallback_OnStartComponent(This->callback, id, size_dl, size_install, display);
+        IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_INITIALIZING, display, NULL, 0, 0);
+        phase = INSTALLSTATUS_INITIALIZING;
+    }
+
+    hr = process_component_dependencies(This, comp);
+    if (FAILED(hr)) return hr;
+
+    if (This->thread.operation == OP_DOWNLOAD)
+    {
+        for (i = 0;; i++)
+        {
+            DWORD flags;
+            char *url;
+
+            phase = INSTALLSTATUS_DOWNLOADING;
+
+            hr = get_url(comp, i, &url, &flags);
+            if (FAILED(hr)) goto done;
+            if (!url) break;
+
+            TRACE("processing url %s\n", debugstr_a(url));
+
+            hr = download_url(This, id, display, url, flags, size_dl);
+            heap_free(url);
+            if (FAILED(hr))
+            {
+                DWORD retry = 0;
+
+                if (This->callback)
+                    IInstallEngineCallback_OnEngineProblem(This->callback, ENGINEPROBLEM_DOWNLOADFAIL, &retry);
+                if (!retry) goto done;
+
+                i--;
+                continue;
+            }
+
+            phase = INSTALLSTATUS_CHECKINGTRUST;
+            /* FIXME: check trust */
+            IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_CHECKINGTRUST, display, NULL, 0, 0);
+        }
+
+        component_set_downloaded(comp, TRUE);
+        phase = INSTALLSTATUS_DOWNLOADFINISHED;
+    }
+    else
+        FIXME("Installation not yet implemented\n");
+
+done:
+    IInstallEngineCallback_OnStopComponent(This->callback, id, hr, phase, display, 0);
+    return hr;
+}
+
+DWORD WINAPI thread_installation(LPVOID param)
+{
+    InstallEngine *This = param;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    if (This->callback)
+        IInstallEngineCallback_OnStartInstall(This->callback, This->thread.download_size, This->thread.install_size);
+
+    for (;;)
+    {
+        hr = get_next_component(This->thread.enum_comp, This->thread.operation, &comp);
+        if (FAILED(hr)) break;
+        if (hr == S_FALSE)
+        {
+            hr = S_OK;
+            break;
+        }
+
+        hr = process_component(This, comp);
+        if (FAILED(hr)) break;
+    }
+
+    if (This->callback)
+        IInstallEngineCallback_OnStopInstall(This->callback, hr, NULL, 0);
+
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    IInstallEngine2_Release(&This->IInstallEngine2_iface);
+
+    set_status(This, ENGINESTATUS_READY);
+    return 0;
+}
+
+static HRESULT start_installation(InstallEngine *This, DWORD operation, DWORD jobflags)
+{
+    HANDLE thread;
+    HRESULT hr;
+
+    This->thread.operation = operation;
+    This->thread.jobflags  = jobflags;
+    This->thread.downloaded_kb = 0;
+    This->thread.download_start = 0;
+
+    /* Windows sends the OnStartInstall event from a different thread,
+     * but OnStartInstall already contains the required download and install size.
+     * The only way to signal an error from the thread is to send an OnStopComponent /
+     * OnStopInstall signal which can only occur after OnStartInstall. We need to
+     * precompute the sizes here to be able inform the application about errors while
+     * calculating the required sizes. */
+
+    hr = ICifFile_EnumComponents(This->icif, &This->thread.enum_comp, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    hr = calc_sizes(This->thread.enum_comp, operation, &This->thread.download_size, &This->thread.install_size);
+    if (FAILED(hr)) goto error;
+
+    IInstallEngine2_AddRef(&This->IInstallEngine2_iface);
+
+    thread = CreateThread(NULL, 0, thread_installation, This, 0, NULL);
+    if (!thread)
+    {
+        IInstallEngine2_Release(&This->IInstallEngine2_iface);
+        hr = E_FAIL;
+        goto error;
+    }
+
+    CloseHandle(thread);
+    return S_OK;
+
+error:
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    return hr;
+}
+
 static HRESULT WINAPI InstallEngine_GetEngineStatus(IInstallEngine2 *iface, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, status);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, status);
+
+    if (!status)
+        return E_FAIL;
+
+    *status = This->status;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetCifFile(IInstallEngine2 *iface, const char *cab_name, const char *cif_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_DownloadComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%x)\n", This, flags);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%x)\n", This, flags);
+
+    /* The interface is not really threadsafe on windows, but we can at least prevent multiple installations */
+    if (InterlockedCompareExchange((LONG *)&This->status, ENGINESTATUS_INSTALLING, ENGINESTATUS_READY) != ENGINESTATUS_READY)
+        return E_FAIL;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, ENGINESTATUS_INSTALLING, 0);
+
+    return start_installation(This, OP_DOWNLOAD, flags);
 }
 
 static HRESULT WINAPI InstallEngine_InstallComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%x)\n", This, flags);
+
+    FIXME("(%p)->(%x): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumInstallIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
+
+    FIXME("(%p)->(%u %p): stub\n", This, index, id);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumDownloadIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
-    return E_NOTIMPL;
+    IEnumCifComponents *enum_components;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%u %p)\n", This, index, id);
+
+    if (!This->icif || !id)
+        return E_FAIL;
+
+    hr = ICifFile_EnumComponents(This->icif, &enum_components, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    for (;;)
+    {
+        hr = IEnumCifComponents_Next(enum_components, &comp);
+        if (FAILED(hr)) goto done;
+
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        if (ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+
+        if (index == 0)
+        {
+            char *id_src = component_get_id(comp);
+            *id = CoTaskMemAlloc(strlen(id_src) + 1);
+
+            if (*id)
+                strcpy(*id, id_src);
+            else
+                hr = E_OUTOFMEMORY;
+            goto done;
+        }
+
+        index--;
+    }
+
+done:
+    IEnumCifComponents_Release(enum_components);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_IsComponentInstalled(IInstallEngine2 *iface, const char *id, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), status);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), status);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_RegisterInstallEngineCallback(IInstallEngine2 *iface, IInstallEngineCallback *callback)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, callback);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, callback);
+
+    This->callback = callback;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_UnregisterInstallEngineCallback(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
-    return E_NOTIMPL;
+
+    TRACE("(%p)\n", This);
+
+    This->callback = NULL;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetAction(IInstallEngine2 *iface, const char *id, DWORD action, DWORD priority)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %d %d)\n", This, debugstr_a(id), action, priority);
-    return E_NOTIMPL;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %u %u)\n", This, debugstr_a(id), action, priority);
+
+    if (!This->icif)
+        return E_FAIL; /* FIXME: check error code */
+
+    hr = ICifFile_FindComponent(This->icif, id, &comp);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetInstallQueueState(comp, action);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetCurrentPriority(comp, priority);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_GetSizes(IInstallEngine2 *iface, const char *id, COMPONENT_SIZES *sizes)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), sizes);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), sizes);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_LaunchExtraCommand(IInstallEngine2 *iface, const char *inf_name, const char *section)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(inf_name), debugstr_a(section));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(inf_name), debugstr_a(section));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_GetDisplayName(IInstallEngine2 *iface, const char *id, const char *name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(id), debugstr_a(name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(id), debugstr_a(name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetBaseUrl(IInstallEngine2 *iface, const char *base_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(base_name));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(base_name));
+
+    if (This->baseurl)
+        heap_free(This->baseurl);
+
+    This->baseurl = strdupA(base_name);
+    return This->baseurl ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetDownloadDir(IInstallEngine2 *iface, const char *download_dir)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(download_dir));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(download_dir));
+
+    if (This->downloaddir)
+        heap_free(This->downloaddir);
+
+    This->downloaddir = strdupA(download_dir);
+    return This->downloaddir ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallDrive(IInstallEngine2 *iface, char drive)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%c)\n", This, drive);
+
+    FIXME("(%p)->(%c): stub\n", This, drive);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallOptions(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%x)\n", This, flags);
+
+    FIXME("(%p)->(%x): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetHWND(IInstallEngine2 *iface, HWND hwnd)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, hwnd);
+
+    FIXME("(%p)->(%p): stub\n", This, hwnd);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetIStream(IInstallEngine2 *iface, IStream *stream)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, stream);
+
+    FIXME("(%p)->(%p): stub\n", This, stream);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Abort(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%x)\n", This, flags);
+
+    FIXME("(%p)->(%x): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Suspend(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Resume(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine2_SetLocalCif(IInstallEngine2 *iface, const char *cif)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(cif));
-    return E_NOTIMPL;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(cif));
+
+    if (This->icif)
+        ICifFile_Release(This->icif);
+
+    set_status(This, ENGINESTATUS_LOADING);
+
+    hr = GetICifFileFromFile(&This->icif, cif);
+    if (SUCCEEDED(hr))
+        set_status(This, ENGINESTATUS_READY);
+    else
+    {
+        This->icif = NULL;
+        set_status(This, ENGINESTATUS_NOTREADY);
+    }
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine2_GetICifFile(IInstallEngine2 *iface, ICifFile **cif_file)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, cif_file);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, cif_file);
+
+    if (!This->icif || !cif_file)
+        return E_FAIL;
+
+    ICifFile_AddRef(This->icif);
+    *cif_file = This->icif;
+    return S_OK;
 }
 
-static const IInstallEngine2Vtbl InstallEngine2Vtbl = {
+static const IInstallEngine2Vtbl InstallEngine2Vtbl =
+{
     InstallEngine_QueryInterface,
     InstallEngine_AddRef,
     InstallEngine_Release,
@@ -290,6 +1134,70 @@ static const IInstallEngine2Vtbl InstallEngine2Vtbl = {
     InstallEngine2_GetICifFile
 };
 
+static HRESULT WINAPI InstallEngineTiming_QueryInterface(IInstallEngineTiming *iface, REFIID riid, void **ppv)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_QueryInterface(&This->IInstallEngine2_iface, riid, ppv);
+}
+
+static ULONG WINAPI InstallEngineTiming_AddRef(IInstallEngineTiming *iface)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_AddRef(&This->IInstallEngine2_iface);
+}
+
+static ULONG WINAPI InstallEngineTiming_Release(IInstallEngineTiming *iface)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_Release(&This->IInstallEngine2_iface);
+}
+
+static HRESULT WINAPI InstallEngineTiming_GetRates(IInstallEngineTiming *iface, DWORD *download, DWORD *install)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+
+    FIXME("(%p)->(%p, %p): stub\n", This, download, install);
+
+    *download = 0;
+    *install = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI InstallEngineTiming_GetInstallProgress(IInstallEngineTiming *iface, INSTALLPROGRESS *progress)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    ULONGLONG elapsed;
+    static int once;
+
+    if (!once)
+        FIXME("(%p)->(%p): semi-stub\n", This, progress);
+    else
+        TRACE("(%p)->(%p): semi-stub\n", This, progress);
+
+    progress->dwDownloadKBRemaining = max(This->thread.download_size, This->thread.downloaded_kb) - This->thread.downloaded_kb;
+
+    elapsed = GetTickCount64() - This->thread.download_start;
+    if (This->thread.download_start && This->thread.downloaded_kb && elapsed > 100)
+        progress->dwDownloadSecsRemaining = (progress->dwDownloadKBRemaining * elapsed) / (This->thread.downloaded_kb * 1000);
+    else
+        progress->dwDownloadSecsRemaining = -1;
+
+    progress->dwInstallKBRemaining = 0;
+    progress->dwInstallSecsRemaining = -1;
+
+    return S_OK;
+}
+
+static const IInstallEngineTimingVtbl InstallEngineTimingVtbl =
+{
+    InstallEngineTiming_QueryInterface,
+    InstallEngineTiming_AddRef,
+    InstallEngineTiming_Release,
+    InstallEngineTiming_GetRates,
+    InstallEngineTiming_GetInstallProgress,
+};
+
 static HRESULT WINAPI ClassFactory_QueryInterface(IClassFactory *iface, REFIID riid, void **ppv)
 {
     *ppv = NULL;
@@ -334,12 +1242,14 @@ static HRESULT WINAPI InstallEngineCF_CreateInstance(IClassFactory *iface, IUnkn
 
     TRACE("(%p %s %p)\n", outer, debugstr_guid(riid), ppv);
 
-    engine = heap_alloc(sizeof(*engine));
+    engine = heap_alloc_zero(sizeof(*engine));
     if(!engine)
         return E_OUTOFMEMORY;
 
     engine->IInstallEngine2_iface.lpVtbl = &InstallEngine2Vtbl;
+    engine->IInstallEngineTiming_iface.lpVtbl = &InstallEngineTimingVtbl;
     engine->ref = 1;
+    engine->status = ENGINESTATUS_NOTREADY;
 
     hres = IInstallEngine2_QueryInterface(&engine->IInstallEngine2_iface, riid, ppv);
     IInstallEngine2_Release(&engine->IInstallEngine2_iface);
diff --git a/dlls/inseng/inseng_private.h b/dlls/inseng/inseng_private.h
new file mode 100644
index 00000000000..55d3899808a
--- /dev/null
+++ b/dlls/inseng/inseng_private.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Michael MÃ¼ller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "ole2.h"
+#include "rpcproxy.h"
+#include "inseng.h"
+#include "wine/heap.h"
+
+
+static inline char *strdupA(const char *src)
+{
+    char *dest = heap_alloc(strlen(src) + 1);
+    if (dest) strcpy(dest, src);
+    return dest;
+}
+
+static inline WCHAR *strdupW(const WCHAR *src)
+{
+    WCHAR *dest;
+    if (!src) return NULL;
+    dest = HeapAlloc(GetProcessHeap(), 0, (lstrlenW(src) + 1) * sizeof(WCHAR));
+    if (dest) lstrcpyW(dest, src);
+    return dest;
+}
+
+static inline LPWSTR strAtoW(const char *str)
+{
+    LPWSTR ret = NULL;
+
+    if (str)
+    {
+        DWORD len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
+        if ((ret = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR))))
+            MultiByteToWideChar(CP_ACP, 0, str, -1, ret, len);
+    }
+
+    return ret;
+}
+
+struct inf_value;
+struct inf_section;
+struct inf_file;
+
+HRESULT inf_load(const char *path, struct inf_file **inf_file) DECLSPEC_HIDDEN;
+void inf_free(struct inf_file *inf) DECLSPEC_HIDDEN;
+
+BOOL inf_next_section(struct inf_file *inf, struct inf_section **sec) DECLSPEC_HIDDEN;
+struct inf_section *inf_get_section(struct inf_file *inf, const char *name) DECLSPEC_HIDDEN;
+char *inf_section_get_name(struct inf_section *section) DECLSPEC_HIDDEN;
+BOOL inf_section_next_value(struct inf_section *sec, struct inf_value **value) DECLSPEC_HIDDEN;
+
+struct inf_value *inf_get_value(struct inf_section *sec, const char *key) DECLSPEC_HIDDEN;
+char *inf_value_get_key(struct inf_value *value) DECLSPEC_HIDDEN;
+char *inf_value_get_value(struct inf_value *value) DECLSPEC_HIDDEN;
+
+char *trim(char *str, char **last_chr, BOOL strip_quotes) DECLSPEC_HIDDEN;
+
+void component_set_actual_download_size(ICifComponent *iface, DWORD size) DECLSPEC_HIDDEN;
+void component_set_downloaded(ICifComponent *iface, BOOL value) DECLSPEC_HIDDEN;
+void component_set_installed(ICifComponent *iface, BOOL value) DECLSPEC_HIDDEN;
+ char *component_get_id(ICifComponent *iface) DECLSPEC_HIDDEN;
diff --git a/include/inseng.idl b/include/inseng.idl
index 8a3f4c4d270..82927418a99 100644
--- a/include/inseng.idl
+++ b/include/inseng.idl
@@ -1,5 +1,6 @@
 /*
  * Copyright 2015 Jacek Caban for CodeWeavers
+ * Copyright 2016 Michael MÃ¼ller
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -26,15 +27,231 @@ cpp_quote("#endif")
 
 interface IStream;
 
-/* FIXME: Add full declarations. */
-interface ICifComponent;
-interface IEnumCifComponents;
-interface ICifGroup;
-interface IEnumCifGroups;
-interface ICifMode;
-interface IEnumCifModes;
+cpp_quote("#define MAX_ID_LENGTH            48")
+cpp_quote("#define MAX_DISPLAYNAME_LENGTH   128")
 
-typedef struct {
+cpp_quote("#define URLF_DEFAULT                 0x0")
+cpp_quote("#define URLF_EXTRACT                 0x1")
+cpp_quote("#define URLF_RELATIVEURL             0x2")
+cpp_quote("#define URLF_DELETE_AFTER_EXTRACT    0x4")
+
+cpp_quote("#define ENGINESTATUS_NOTREADY    0x0")
+cpp_quote("#define ENGINESTATUS_LOADING     0x1")
+cpp_quote("#define ENGINESTATUS_INSTALLING  0x2")
+cpp_quote("#define ENGINESTATUS_READY       0x3")
+
+cpp_quote("#define SETACTION_NONE       0x0")
+cpp_quote("#define SETACTION_INSTALL    0x1")
+
+cpp_quote("#define INSTALLOPTIONS_NOCACHE               0x01")
+cpp_quote("#define INSTALLOPTIONS_DOWNLOAD              0x02")
+cpp_quote("#define INSTALLOPTIONS_INSTALL               0x04")
+cpp_quote("#define INSTALLOPTIONS_DONTALLOWXPLATFORM    0x08")
+cpp_quote("#define INSTALLOPTIONS_FORCEDEPENDENCIES     0x10")
+
+cpp_quote("#define EXECUTEJOB_SILENT                0x01")
+cpp_quote("#define EXECUTEJOB_DELETE_JOB            0x02")
+cpp_quote("#define EXECUTEJOB_VERIFYFILES           0x08")
+cpp_quote("#define EXECUTEJOB_IGNORETRUST           0x10")
+cpp_quote("#define EXECUTEJOB_IGNOREDOWNLOADERROR   0x20")
+cpp_quote("#define EXECUTEJOB_DONTALLOWCANCEL       0x40")
+
+cpp_quote("#define ENGINEPROBLEM_DOWNLOADFAIL   0x1")
+
+cpp_quote("#define PLATFORM_WIN95       0x01")
+cpp_quote("#define PLATFORM_WIN98       0x02")
+cpp_quote("#define PLATFORM_NT4         0x04")
+cpp_quote("#define PLATFORM_NT5         0x08")
+cpp_quote("#define PLATFORM_NT4ALPHA    0x10")
+cpp_quote("#define PLATFORM_NT5ALPHA    0x20")
+cpp_quote("#define PLATFORM_MILLEN      0x40")
+cpp_quote("#define PLATFORM_ALL         (PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN)")
+
+enum InstallStatus
+{
+    INSTALLSTATUS_INITIALIZING,
+    INSTALLSTATUS_DEPENDENCY,
+    INSTALLSTATUS_DOWNLOADING,
+    INSTALLSTATUS_COPYING,
+    INSTALLSTATUS_RETRYING,
+    INSTALLSTATUS_CHECKINGTRUST,
+    INSTALLSTATUS_EXTRACTING,
+    INSTALLSTATUS_RUNNING,
+    INSTALLSTATUS_FINISHED,
+    INSTALLSTATUS_DOWNLOADFINISHED,
+};
+
+enum ComponentAction
+{
+    ActionNone,
+    ActionInstall,
+    ActionUninstall,
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifComponent
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetGUID(char *guid, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    HRESULT GetDetails(char *details, DWORD size);
+    HRESULT GetUrl(UINT index, char *url, DWORD size, DWORD *flags);
+    HRESULT GetFileExtractList(UINT index, char *extract, DWORD size);
+    HRESULT GetUrlCheckRange(UINT index, DWORD *min, DWORD *max);
+    HRESULT GetCommand(UINT index, char *cmd, DWORD cmd_size, char *switches, DWORD switch_size, DWORD *type);
+    HRESULT GetVersion(DWORD *version, DWORD *build);
+    HRESULT GetLocale(char *pszLocale, DWORD size);
+    HRESULT GetUninstallKey(char *key, DWORD size);
+    HRESULT GetInstalledSize(DWORD *win, DWORD *app);
+    DWORD GetDownloadSize();
+    DWORD GetExtractSize();
+    HRESULT GetSuccessKey(char *key, DWORD size);
+    HRESULT GetProgressKeys(char *progress, DWORD progress_size, char *cancel, DWORD cancel_size);
+    HRESULT IsActiveSetupAware();
+    HRESULT IsRebootRequired();
+    HRESULT RequiresAdminRights();
+    DWORD GetPriority();
+    HRESULT GetDependency(UINT index, char *id, DWORD buf, char *type, DWORD *ver, DWORD *build);
+    DWORD GetPlatform();
+    HRESULT GetMode(UINT index, char *mode, DWORD size);
+    HRESULT GetGroup(char *id, DWORD size);
+    HRESULT IsUIVisible();
+    HRESULT GetPatchID(char *id, DWORD size);
+    HRESULT GetDetVersion(char *dll, DWORD dll_size, char *entry, DWORD entry_size);
+    HRESULT GetTreatAsOneComponents(UINT index, char *id, DWORD buf);
+    HRESULT GetCustomData(char *key, char *data, DWORD size);
+    DWORD IsComponentInstalled();
+    HRESULT IsComponentDownloaded();
+    DWORD IsThisVersionInstalled(DWORD version, DWORD build, DWORD *ret_version, DWORD *ret_build);
+    DWORD GetInstallQueueState();
+    HRESULT SetInstallQueueState(DWORD state);
+    DWORD GetActualDownloadSize();
+    DWORD GetCurrentPriority();
+    HRESULT SetCurrentPriority(DWORD priority);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWComponent : ICifComponent
+{
+    HRESULT SetGUID(const char *guid);
+    HRESULT SetDescription(const char *desc);
+    HRESULT SetUrl(UINT index, const char *url, DWORD url_flags);
+    HRESULT SetCommand(UINT index, const char *cmd, const char *switches, DWORD type);
+    HRESULT SetVersion(const char *version);
+    HRESULT SetUninstallKey(const char *key);
+    HRESULT SetInstalledSize(DWORD win, DWORD app);
+    HRESULT SetDownloadSize(DWORD size);
+    HRESULT SetExtractSize(DWORD size);
+    HRESULT DeleteDependency(const char *id, char type);
+    HRESULT AddDependency(const char *id, char type);
+    HRESULT SetUIVisible(BOOL visible);
+    HRESULT SetGroup(const char *id);
+    HRESULT SetPlatform(DWORD platform);
+    HRESULT SetPriority(DWORD priority);
+    HRESULT SetReboot(BOOL reboot);
+    HRESULT DeleteFromModes(const char *mode);
+    HRESULT AddToMode(const char *mode);
+    HRESULT SetModes(const char *mode);
+    HRESULT CopyComponent(const char *ciffile);
+    HRESULT AddToTreatAsOne(const char *compid);
+    HRESULT SetDetails(const char *desc);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifComponents : IUnknown
+{
+    HRESULT Next(ICifComponent **);
+    HRESULT Reset();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifGroup
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    DWORD GetPriority();
+
+    HRESULT EnumComponents(IEnumCifComponents **, DWORD filter, void *pv);
+    DWORD GetCurrentPriority();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWGroup : ICifGroup
+{
+   HRESULT SetDescription(const char *desc);
+   HRESULT SetPriority(DWORD priority);
+   HRESULT SetDetails(const char *details);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifGroups : IUnknown
+{
+    HRESULT Next(ICifGroup **);
+    HRESULT Reset();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifMode
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    HRESULT GetDetails(char *details, DWORD size);
+
+    HRESULT EnumComponents(IEnumCifComponents **, DWORD filter, void *pv);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWMode : ICifMode
+{
+    HRESULT SetDescription(const char *desc);
+    HRESULT SetDetails(const char *details);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifModes : IUnknown
+{
+    HRESULT Next(ICifMode **);
+    HRESULT Reset();
+};
+
+typedef struct
+{
     DWORD cbSize;
     DWORD dwInstallSize;
     DWORD dwWinDriveSize;
@@ -49,6 +266,15 @@ typedef struct {
     DWORD dwTotalDownloadSize;
 } COMPONENT_SIZES;
 
+typedef struct
+{
+    DWORD cbSize;
+    DWORD dwDownloadKBRemaining;
+    DWORD dwInstallKBRemaining;
+    DWORD dwDownloadSecsRemaining;
+    DWORD dwInstallSecsRemaining;
+} INSTALLPROGRESS;
+
 [
     uuid(6e449688-c509-11cf-aafa-00aa00b6015c),
     local
@@ -62,7 +288,24 @@ interface ICifFile : IUnknown
     HRESULT EnumModes(IEnumCifModes **cuf_modes, DWORD filter, void *pv);
     HRESULT FindMode(const char *id, ICifMode **p);
     HRESULT GetDescription(char *desc, DWORD size);
-    HRESULT GetDetDlls(char **dlls, DWORD size);
+    HRESULT GetDetDlls(char *dlls, DWORD size);
+}
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWFile : ICifFile
+{
+    HRESULT SetDescription(const char *desc);
+    HRESULT CreateComponent(const char *id, ICifRWComponent **p);
+    HRESULT CreateGroup(const char *id, ICifRWGroup **p);
+    HRESULT CreateMode(const char *id, ICifRWMode **p);
+    HRESULT DeleteComponent(const char *id);
+    HRESULT DeleteGroup(const char *id);
+    HRESULT DeleteMode(const char *id);
+    HRESULT Flush();
 }
 
 [
@@ -78,7 +321,7 @@ interface IInstallEngineCallback : IUnknown
            const char *msg_string, ULONG progress, ULONG max);
    HRESULT OnStopComponent(const char *id, HRESULT error, DWORD phrase, const char *string, DWORD status);
    HRESULT OnStopInstall(HRESULT error, const char *error_string, DWORD status);
-   HRESULT OnEngineProblem(DWORD problem, LPDWORD action);
+   HRESULT OnEngineProblem(DWORD problem, DWORD *action);
 }
 
 [
@@ -121,6 +364,16 @@ interface IInstallEngine2 : IInstallEngine
     HRESULT GetICifFile(ICifFile **cif_file);
 }
 
+[
+    uuid(6e449687-c509-11cf-aafa-00aa00b6015c),
+    local
+]
+interface IInstallEngineTiming : IUnknown
+{
+    HRESULT GetRates(DWORD *download, DWORD *install);
+    HRESULT GetInstallProgress(INSTALLPROGRESS *progress);
+}
+
 [
     helpstring("Microsoft Active Setup Engine"),
     threading(apartment),
@@ -134,3 +387,6 @@ coclass InstallEngine { }
     uuid(bfc880f1-7484-11d0-8309-00aa00b6015c)
 ]
 coclass DownloadSiteMgr { }
+
+cpp_quote("HRESULT WINAPI GetICifFileFromFile(ICifFile **, const char *);")
+cpp_quote("HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **, const char *);")
-- 
2.33.0


From 717a66470ad13872e7e346e7c6de97da1ba1ee2f Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 7 Dec 2020 12:59:55 +0300
Subject: [PATCH 1/6] bcrypt: Implement DH.

---
 dlls/bcrypt/bcrypt_internal.h |  14 +++
 dlls/bcrypt/bcrypt_main.c     | 174 +++++++++++++++++++++++++--
 dlls/bcrypt/gnutls.c          | 217 +++++++++++++++++++++++++++++++++-
 include/bcrypt.h              |  29 +++++
 4 files changed, 426 insertions(+), 8 deletions(-)

diff --git a/dlls/bcrypt/bcrypt_internal.h b/dlls/bcrypt/bcrypt_internal.h
index 0a600a2ebb5..ae771d085c2 100644
--- a/dlls/bcrypt/bcrypt_internal.h
+++ b/dlls/bcrypt/bcrypt_internal.h
@@ -131,6 +131,7 @@ enum alg_id
     ALG_ID_RSA,

     /* secret agreement */
+    ALG_ID_DH,
     ALG_ID_ECDH_P256,

     /* signature */
@@ -170,6 +171,8 @@ struct key_symmetric
 };

 #define KEY_FLAG_LEGACY_DSA_V2  0x00000001
+#define KEY_FLAG_DH_PARAMS_SET  0x00000002
+#define KEY_FLAG_FINALIZED      0x00000004

 struct key_asymmetric
 {
@@ -177,6 +180,7 @@ struct key_asymmetric
     unsigned          flags;
     UCHAR            *pubkey;
     unsigned          pubkey_len;
+    UCHAR            *privkey;    /* Used for DH private key only. */
     DSSSEED           dss_seed;
 };

@@ -195,6 +199,8 @@ struct key
 struct secret
 {
     struct object hdr;
+    UCHAR *data;
+    ULONG  data_len;
 };

 struct key_symmetric_set_auth_data_params
@@ -283,6 +289,13 @@ struct key_import_params
     ULONG        len;
 };

+struct key_secret_agreement_params
+{
+    struct key *privkey;
+    struct key *pubkey;
+    struct secret *secret;
+};
+
 enum key_funcs
 {
     unix_process_attach,
@@ -304,6 +317,7 @@ enum key_funcs
     unix_key_import_dsa_capi,
     unix_key_import_ecc,
     unix_key_import_rsa,
+    unix_key_secret_agreement,
 };

 #endif /* __BCRYPT_INTERNAL_H */
diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
index 9e0d06e9cc7..889f6ce85ea 100644
--- a/dlls/bcrypt/bcrypt_main.c
+++ b/dlls/bcrypt/bcrypt_main.c
@@ -112,6 +112,7 @@ builtin_algorithms[] =
     {  BCRYPT_MD4_ALGORITHM,        BCRYPT_HASH_INTERFACE,                  270,   16,  512 },
     {  BCRYPT_MD2_ALGORITHM,        BCRYPT_HASH_INTERFACE,                  270,   16,  128 },
     {  BCRYPT_RSA_ALGORITHM,        BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE, 0,      0,    0 },
+    {  BCRYPT_DH_ALGORITHM,         BCRYPT_SECRET_AGREEMENT_INTERFACE,      0,      0,    0 },
     {  BCRYPT_ECDH_P256_ALGORITHM,  BCRYPT_SECRET_AGREEMENT_INTERFACE,      0,      0,    0 },
     {  BCRYPT_RSA_SIGN_ALGORITHM,   BCRYPT_SIGNATURE_INTERFACE,             0,      0,    0 },
     {  BCRYPT_ECDSA_P256_ALGORITHM, BCRYPT_SIGNATURE_INTERFACE,             0,      0,    0 },
@@ -713,6 +714,33 @@ static NTSTATUS get_hash_property( const struct hash *hash, const WCHAR *prop, U
     return status;
 }

+static NTSTATUS get_dh_property( const struct key *key, const WCHAR *prop, UCHAR *buf, ULONG size, ULONG *ret_size )
+{
+    BCRYPT_DH_PARAMETER_HEADER *h = (BCRYPT_DH_PARAMETER_HEADER *)buf;
+    ULONG data_size;
+
+    if (wcscmp( prop, BCRYPT_DH_PARAMETERS )) return STATUS_NOT_SUPPORTED;
+    if (!(key->u.a.flags & KEY_FLAG_FINALIZED)) return STATUS_INVALID_HANDLE;
+
+    data_size = sizeof(BCRYPT_DH_PARAMETER_HEADER) + key->u.a.bitlen / 8 * 2;
+
+    if (ret_size)
+        *ret_size = data_size;
+
+    if (!buf)
+        return STATUS_SUCCESS;
+
+    if (size < data_size)
+        return STATUS_BUFFER_TOO_SMALL;
+
+    h->cbLength = data_size;
+    h->dwMagic = BCRYPT_DH_PARAMETERS_MAGIC;
+    h->cbKeyLength = key->u.a.bitlen / 8;
+    memcpy( h + 1, (BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1, h->cbKeyLength * 2);
+
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS get_key_property( const struct key *key, const WCHAR *prop, UCHAR *buf, ULONG size, ULONG *ret_size )
 {
     switch (key->alg_id)
@@ -724,6 +752,9 @@ static NTSTATUS get_key_property( const struct key *key, const WCHAR *prop, UCHA
         if (!wcscmp( prop, BCRYPT_AUTH_TAG_LENGTH )) return STATUS_NOT_SUPPORTED;
         return get_aes_property( key->u.s.mode, prop, buf, size, ret_size );

+    case ALG_ID_DH:
+        return get_dh_property( key, prop, buf, size, ret_size );
+
     default:
         FIXME( "unsupported algorithm %u\n", key->alg_id );
         return STATUS_NOT_IMPLEMENTED;
@@ -975,6 +1006,21 @@ static NTSTATUS key_asymmetric_create( struct key **ret_key, struct algorithm *a
     key->hdr.magic  = MAGIC_KEY;
     key->alg_id     = alg->id;
     key->u.a.bitlen = bitlen;
+
+    if (alg->id == ALG_ID_DH)
+    {
+        if (bitlen < 512)
+        {
+            free( key );
+            return STATUS_INVALID_PARAMETER;
+        }
+        pubkey_len = sizeof(BCRYPT_DH_KEY_BLOB) + bitlen / 8 * 3;
+        if (!(key->u.a.privkey = malloc( bitlen / 8 )))
+        {
+            free( key );
+            return STATUS_NO_MEMORY;
+        }
+    }
     key->u.a.pubkey_len = pubkey_len;

     if (!(key->u.a.pubkey = malloc( pubkey_len )))
@@ -1063,6 +1109,7 @@ static NTSTATUS key_import( BCRYPT_ALG_HANDLE algorithm, const WCHAR *type, BCRY
 static NTSTATUS key_export( struct key *key, const WCHAR *type, UCHAR *output, ULONG output_len, ULONG *size )
 {
     struct key_export_params params;
+    BOOL dh_private = FALSE;

     if (!wcscmp( type, BCRYPT_KEY_DATA_BLOB ))
     {
@@ -1117,6 +1164,27 @@ static NTSTATUS key_export( struct key *key, const WCHAR *type, UCHAR *output, U
         params.ret_len = size;
         return UNIX_CALL( key_export_dsa_capi, &params );
     }
+    else if (!wcscmp( type, BCRYPT_DH_PUBLIC_BLOB ) || (dh_private = !wcscmp( type, BCRYPT_DH_PRIVATE_BLOB )))
+    {
+        BCRYPT_DH_KEY_BLOB *h = (BCRYPT_DH_KEY_BLOB *)output;
+
+        if (!(key->u.a.flags & KEY_FLAG_FINALIZED))
+            return STATUS_INVALID_HANDLE;
+
+        *size = key->u.a.pubkey_len;
+        if (dh_private)
+            *size += key->u.a.bitlen / 8;
+
+        if (output_len < *size) return STATUS_SUCCESS;
+        memcpy(output, key->u.a.pubkey, key->u.a.pubkey_len);
+        if (dh_private)
+            memcpy(output + key->u.a.pubkey_len, key->u.a.privkey, key->u.a.bitlen / 8);
+
+        h->dwMagic = dh_private ? BCRYPT_DH_PRIVATE_MAGIC : BCRYPT_DH_PUBLIC_MAGIC;
+        h->cbKey = key->u.a.bitlen / 8;
+
+        return STATUS_SUCCESS;
+    }

     FIXME( "unsupported key type %s\n", debugstr_w(type) );
     return STATUS_NOT_IMPLEMENTED;
@@ -1311,6 +1379,7 @@ static NTSTATUS key_import_pair( struct algorithm *alg, const WCHAR *type, BCRYP
                                  ULONG input_len )
 {
     struct key_import_params params;
+    BOOL dh_private = FALSE;
     struct key *key;
     NTSTATUS status;
     ULONG size;
@@ -1505,6 +1574,32 @@ static NTSTATUS key_import_pair( struct algorithm *alg, const WCHAR *type, BCRYP
         *ret_key = key;
         return STATUS_SUCCESS;
     }
+    else if (!wcscmp( type, BCRYPT_DH_PUBLIC_BLOB ) || (dh_private = !wcscmp( type, BCRYPT_DH_PRIVATE_BLOB )))
+    {
+        BCRYPT_DH_KEY_BLOB *h = (BCRYPT_DH_KEY_BLOB *)input;
+        ULONG size;
+
+        if (alg->id != ALG_ID_DH) return STATUS_NOT_SUPPORTED;
+        if (h->dwMagic != (dh_private ? BCRYPT_DH_PRIVATE_MAGIC : BCRYPT_DH_PUBLIC_MAGIC))
+        {
+            WARN("unexpected dwMagic %#x.\n", h->dwMagic);
+            return STATUS_INVALID_PARAMETER;
+        }
+
+        size = sizeof(*h) + h->cbKey * 3;
+        if (dh_private)
+            size += h->cbKey;
+        if (input_len != size) return STATUS_INVALID_PARAMETER;
+        if (h->cbKey * 8 < 512) return STATUS_INVALID_PARAMETER;
+
+        if ((status = key_asymmetric_create( &key, alg, h->cbKey * 8, input, 0 ))) return status;
+
+        if (dh_private)
+            memcpy( key->u.a.privkey, input + sizeof(*h) + h->cbKey * 3, h->cbKey);
+
+        *ret_key = key;
+        return STATUS_SUCCESS;
+    }

     FIXME( "unsupported key type %s\n", debugstr_w(type) );
     return STATUS_NOT_SUPPORTED;
@@ -1586,6 +1681,9 @@ NTSTATUS WINAPI BCryptGenerateKeyPair( BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_H
     case ALG_ID_DSA:
         size = sizeof(BCRYPT_DSA_KEY_BLOB) + 3 * key_len / 8;
         break;
+    case ALG_ID_DH:
+        size = sizeof(BCRYPT_DH_KEY_BLOB) + key_len / 8 * 3;
+        break;
     default:
         FIXME( "algorithm %u not supported\n", alg->id );
         return STATUS_NOT_SUPPORTED;
@@ -1598,11 +1696,15 @@ NTSTATUS WINAPI BCryptGenerateKeyPair( BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_H
 NTSTATUS WINAPI BCryptFinalizeKeyPair( BCRYPT_KEY_HANDLE handle, ULONG flags )
 {
     struct key *key = handle;
+    NTSTATUS ret;

     TRACE( "%p, %#lx\n", key, flags );
     if (!key || key->hdr.magic != MAGIC_KEY) return STATUS_INVALID_HANDLE;

-    return UNIX_CALL( key_asymmetric_generate, key );
+    if (!(ret = UNIX_CALL( key_asymmetric_generate, key )))
+        key->u.a.flags |= KEY_FLAG_FINALIZED;
+
+    return ret;
 }

 NTSTATUS WINAPI BCryptImportKey( BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_HANDLE decrypt_key, const WCHAR *type,
@@ -1678,6 +1780,13 @@ static NTSTATUS key_duplicate( struct key *key_orig, struct key *key_copy )
         key_copy->u.a.pubkey_len = key_orig->u.a.pubkey_len;
         key_copy->u.a.dss_seed   = key_orig->u.a.dss_seed;

+        if (key_orig->alg_id == ALG_ID_DH && key_orig->u.a.privkey)
+        {
+            if (!(buffer = malloc( key_orig->u.a.bitlen / 8 ))) return STATUS_NO_MEMORY;
+            memcpy( buffer, key_orig->u.a.privkey, key_orig->u.a.bitlen / 8 );
+            key_copy->u.a.privkey = buffer;
+        }
+
         params.key_orig = key_orig;
         params.key_copy = key_copy;
         if ((status = UNIX_CALL( key_asymmetric_duplicate, &params ))) return status;
@@ -1699,6 +1808,7 @@ static void key_destroy( struct key *key )
     {
         UNIX_CALL( key_asymmetric_destroy, key );
         free( key->u.a.pubkey );
+        free( key->u.a.privkey );
     }
     key->hdr.magic = 0;
     free( key );
@@ -1732,6 +1842,7 @@ NTSTATUS WINAPI BCryptImportKeyPair( BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_HAN
                                      BCRYPT_KEY_HANDLE *ret_key, UCHAR *input, ULONG input_len, ULONG flags )
 {
     struct algorithm *alg = algorithm;
+    NTSTATUS status;

     TRACE( "%p, %p, %s, %p, %p, %u, %08x\n", algorithm, decrypt_key, debugstr_w(type), ret_key, input,
            input_len, flags );
@@ -1744,7 +1855,10 @@ NTSTATUS WINAPI BCryptImportKeyPair( BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_HAN
         return STATUS_NOT_IMPLEMENTED;
     }

-    return key_import_pair( alg, type, ret_key, input, input_len );
+    if (!(status = key_import_pair( alg, type, ret_key, input, input_len )))
+        ((struct key *)*ret_key)->u.a.flags |= KEY_FLAG_FINALIZED;
+
+    return status;
 }

 NTSTATUS WINAPI BCryptSignHash( BCRYPT_KEY_HANDLE handle, void *padding, UCHAR *input, ULONG input_len,
@@ -1887,6 +2001,29 @@ NTSTATUS WINAPI BCryptSetProperty( BCRYPT_HANDLE handle, const WCHAR *prop, UCHA
     case MAGIC_KEY:
     {
         struct key *key = (struct key *)object;
+
+        if (key->alg_id == ALG_ID_DH)
+        {
+            if (!lstrcmpW( prop, BCRYPT_DH_PARAMETERS ))
+            {
+                const BCRYPT_DH_PARAMETER_HEADER *h = (const BCRYPT_DH_PARAMETER_HEADER *)value;
+                ULONG param_size = sizeof(BCRYPT_DH_PARAMETER_HEADER) + key->u.a.bitlen / 8 * 2;
+
+                if (key->u.a.flags & KEY_FLAG_FINALIZED)
+                    return STATUS_INVALID_HANDLE;
+
+                if (size < param_size)
+                    return STATUS_BUFFER_TOO_SMALL;
+                if (!h || h->cbLength != param_size || h->dwMagic != BCRYPT_DH_PARAMETERS_MAGIC
+                        || h->cbKeyLength != key->u.a.bitlen / 8)
+                    return STATUS_INVALID_PARAMETER;
+
+                memcpy((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1, h + 1, h->cbKeyLength * 2);
+                key->u.a.flags |= KEY_FLAG_DH_PARAMS_SET;
+                return STATUS_SUCCESS;
+            }
+            return STATUS_NOT_IMPLEMENTED;
+        }
         return set_key_property( key, prop, value, size, flags );
     }
     default:
@@ -2043,31 +2180,54 @@ NTSTATUS WINAPI BCryptDeriveKeyPBKDF2( BCRYPT_ALG_HANDLE handle, UCHAR *pwd, ULO

 NTSTATUS WINAPI BCryptSecretAgreement(BCRYPT_KEY_HANDLE privatekey, BCRYPT_KEY_HANDLE publickey, BCRYPT_SECRET_HANDLE *handle, ULONG flags)
 {
+    struct key_secret_agreement_params params;
     struct key *privkey = privatekey;
     struct key *pubkey = publickey;
     struct secret *secret;
+    NTSTATUS status;

-    FIXME( "%p, %p, %p, %#lx\n", privatekey, publickey, handle, flags );
+    TRACE( "%p, %p, %p, %#lx\n", privatekey, publickey, handle, flags );

     if (!privkey || privkey->hdr.magic != MAGIC_KEY) return STATUS_INVALID_HANDLE;
     if (!pubkey || pubkey->hdr.magic != MAGIC_KEY) return STATUS_INVALID_HANDLE;
     if (!handle) return STATUS_INVALID_PARAMETER;
+    if (key_is_symmetric( privkey ) || privkey->alg_id != pubkey->alg_id) return STATUS_INVALID_PARAMETER;
+    if (!(privkey->u.a.flags & pubkey->u.a.flags & KEY_FLAG_FINALIZED)) return STATUS_INVALID_PARAMETER;
+    if (privkey->u.a.bitlen != pubkey->u.a.bitlen) return STATUS_INVALID_PARAMETER;

     if (!(secret = calloc( 1, sizeof(*secret) ))) return STATUS_NO_MEMORY;
-    secret->hdr.magic = MAGIC_SECRET;
+    if (!(secret->data = malloc( privkey->u.a.bitlen / 8 )))
+    {
+        free( secret );
+        return STATUS_NO_MEMORY;
+    }

-    *handle = secret;
-    return STATUS_SUCCESS;
+    params.privkey = privkey;
+    params.pubkey = pubkey;
+    params.secret = secret;
+
+    if ((status = UNIX_CALL( key_secret_agreement, &params )))
+    {
+        free( secret );
+        free( secret->data );
+    }
+    else
+    {
+        secret->hdr.magic = MAGIC_SECRET;
+        *handle = secret;
+    }
+    return status;
 }

 NTSTATUS WINAPI BCryptDestroySecret(BCRYPT_SECRET_HANDLE handle)
 {
     struct secret *secret = handle;

-    FIXME( "%p\n", handle );
+    TRACE( "%p\n", handle );

     if (!secret || secret->hdr.magic != MAGIC_SECRET) return STATUS_INVALID_HANDLE;
     secret->hdr.magic = 0;
+    free( secret->data );
     free( secret );
     return STATUS_SUCCESS;
 }
diff --git a/dlls/bcrypt/gnutls.c b/dlls/bcrypt/gnutls.c
index a015d85f85d..a751310c883 100644
--- a/dlls/bcrypt/gnutls.c
+++ b/dlls/bcrypt/gnutls.c
@@ -34,6 +35,7 @@
 #include <gnutls/gnutls.h>
 #include <gnutls/crypto.h>
 #include <gnutls/abstract.h>
+#include <fcntl.h>

 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -80,6 +80,8 @@ static union key_data *key_data( struct key *key )
     return (union key_data *)key->private;
 }

+static BOOL dh_supported;
+
 /* Not present in gnutls version < 3.0 */
 static int (*pgnutls_cipher_tag)(gnutls_cipher_hd_t, void *, size_t);
 static int (*pgnutls_cipher_add_auth)(gnutls_cipher_hd_t, const void *, size_t);
@@ -115,6 +117,17 @@ static int (*pgnutls_privkey_decrypt_data)(gnutls_privkey_t, unsigned int flags,
 /* Not present in gnutls version < 3.6.0 */
 static int (*pgnutls_decode_rs_value)(const gnutls_datum_t *, gnutls_datum_t *, gnutls_datum_t *);

+static int (*pgnutls_dh_params_init)(gnutls_dh_params_t * dh_params);
+static void (*pgnutls_dh_params_deinit)(gnutls_dh_params_t dh_params);
+static int (*pgnutls_dh_params_generate2)(gnutls_dh_params_t dparams, unsigned int bits);
+static int (*pgnutls_dh_params_import_raw2)(gnutls_dh_params_t dh_params, const gnutls_datum_t * prime,
+        const gnutls_datum_t * generator, unsigned key_bits);
+static int (*pgnutls_dh_params_export_raw)(gnutls_dh_params_t params, gnutls_datum_t * prime,
+        gnutls_datum_t * generator, unsigned int *bits);
+static int (*pgnutls_dh_generate_key)(gnutls_dh_params_t dh_params, gnutls_datum_t *priv_key, gnutls_datum_t *pub_key);
+static int (*pgnutls_dh_compute_key)(gnutls_dh_params_t dh_params, const gnutls_datum_t *priv_key,
+        const gnutls_datum_t *pub_key, const gnutls_datum_t *peer_key, gnutls_datum_t *Z);
+
 static void *libgnutls_handle;
 #define MAKE_FUNCPTR(f) static typeof(f) * p##f
 MAKE_FUNCPTR(gnutls_cipher_decrypt2);
@@ -303,6 +316,39 @@ static NTSTATUS gnutls_process_attach( void *args )
         pgnutls_perror( ret );
         goto fail;
     }
+    if (!(pgnutls_dh_params_init = dlsym( libgnutls_handle, "gnutls_dh_params_init" )))
+    {
+        WARN("gnutls_dh_params_init not found\n");
+    }
+    if (!(pgnutls_dh_params_deinit = dlsym( libgnutls_handle, "gnutls_dh_params_deinit" )))
+    {
+        WARN("gnutls_dh_params_deinit not found\n");
+    }
+    if (!(pgnutls_dh_params_generate2 = dlsym( libgnutls_handle, "gnutls_dh_params_generate2" )))
+    {
+        WARN("gnutls_dh_params_generate2 not found\n");
+    }
+    if (!(pgnutls_dh_params_import_raw2 = dlsym( libgnutls_handle, "gnutls_dh_params_import_raw2" )))
+    {
+        WARN("gnutls_dh_params_import_raw2 not found\n");
+    }
+    if (!(pgnutls_dh_params_export_raw = dlsym( libgnutls_handle, "gnutls_dh_params_export_raw" )))
+    {
+        WARN("gnutls_dh_params_export_raw not found\n");
+    }
+    if (!(pgnutls_dh_generate_key = dlsym( libgnutls_handle, "_gnutls_dh_generate_key" ))
+            && !(pgnutls_dh_generate_key = dlsym( libgnutls_handle, "gnutls_dh_generate_key" )))
+    {
+        WARN("gnutls_dh_generate_key not found\n");
+    }
+    if (!(pgnutls_dh_compute_key = dlsym( libgnutls_handle, "_gnutls_dh_compute_key" ))
+            && !(pgnutls_dh_compute_key = dlsym( libgnutls_handle, "gnutls_dh_compute_key" )))
+    {
+        WARN("gnutls_dh_compute_key not found\n");
+    }
+
+    dh_supported = pgnutls_dh_params_init && pgnutls_dh_params_generate2 && pgnutls_dh_params_import_raw2
+            && pgnutls_dh_generate_key && pgnutls_dh_compute_key;

     if (TRACE_ON( bcrypt ))
     {
@@ -836,6 +882,87 @@ static NTSTATUS export_gnutls_pubkey_dsa_capi( gnutls_privkey_t gnutls_key, cons
     return STATUS_SUCCESS;
 }

+static NTSTATUS CDECL key_dh_generate( struct key *key )
+{
+    gnutls_datum_t prime, generator, privkey, pubkey;
+    NTSTATUS status = STATUS_SUCCESS;
+    gnutls_dh_params_t dh_params;
+    ULONG key_length;
+    int ret;
+
+    if (!dh_supported)
+    {
+        ERR("DH is not available.\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    if ((ret = pgnutls_dh_params_init( &dh_params )))
+    {
+        pgnutls_perror( ret );
+        return STATUS_INTERNAL_ERROR;
+    }
+
+    key_length = key->u.a.bitlen / 8;
+
+    if (!(key->u.a.flags & KEY_FLAG_DH_PARAMS_SET))
+    {
+        /* Generate parameters, export and then import them back below.
+         * The bitlen in dh parameters (which is later used for keys generation)
+         * is not set to gnutls_dh_params_generate2 'bits' parameter as one
+         * could expect. gnutls_dh_params_generate2 generates 'q' (which is not
+         * actually needed for DH) with the estimated bit length and then
+         * sets the bit length to the 'q' bitlength. */
+        if ((ret = pgnutls_dh_params_generate2( dh_params, key->u.a.bitlen )))
+        {
+            pgnutls_perror( ret );
+            pgnutls_dh_params_deinit( dh_params );
+            return STATUS_INTERNAL_ERROR;
+        }
+        if ((ret = pgnutls_dh_params_export_raw( dh_params, &prime, &generator, NULL )))
+        {
+            pgnutls_perror( ret );
+            pgnutls_dh_params_deinit( dh_params );
+            return STATUS_INTERNAL_ERROR;
+        }
+
+        export_gnutls_datum( (UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1), key_length, &prime, NULL );
+        export_gnutls_datum( (UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + key_length,
+                key_length, &generator, NULL );
+        free( prime.data );
+        free( generator.data );
+
+        key->u.a.flags |= KEY_FLAG_DH_PARAMS_SET;
+    }
+
+    prime.size = generator.size = key_length;
+    prime.data = (UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1);
+    generator.data = (BYTE *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + key_length;
+
+    if ((ret = pgnutls_dh_params_import_raw2( dh_params, &prime, &generator, key->u.a.bitlen )))
+    {
+        pgnutls_perror( ret );
+        pgnutls_dh_params_deinit( dh_params );
+        return STATUS_INTERNAL_ERROR;
+    }
+
+    if ((ret = pgnutls_dh_generate_key( dh_params, &privkey, &pubkey )))
+    {
+        pgnutls_perror( ret );
+        pgnutls_dh_params_deinit( dh_params );
+        return STATUS_INTERNAL_ERROR;
+    }
+
+    export_gnutls_datum( (BYTE *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + 2 * key_length,
+            key_length, &pubkey, NULL );
+    export_gnutls_datum( key->u.a.privkey, key_length, &privkey, NULL);
+
+    free( privkey.data );
+    free( pubkey.data );
+    pgnutls_dh_params_deinit( dh_params );
+
+    return status;
+}
+
 static NTSTATUS key_asymmetric_generate( void *args )
 {
     struct key *key = args;
@@ -866,6 +993,9 @@ static NTSTATUS key_asymmetric_generate( void *args )
         bitlen = GNUTLS_CURVE_TO_BITS( GNUTLS_ECC_CURVE_SECP256R1 );
         break;

+    case ALG_ID_DH:
+        return key_dh_generate( key );
+
     default:
         FIXME( "algorithm %u not supported\n", key->alg_id );
         return STATUS_NOT_SUPPORTED;
@@ -879,6 +1009,7 @@ static NTSTATUS key_asymmetric_generate( void *args )

     if ((ret = pgnutls_privkey_generate( handle, pk_alg, bitlen, 0 )))
     {
+        ERR("gnutls error bitlen %u.\n", bitlen);
         pgnutls_perror( ret );
         pgnutls_privkey_deinit( handle );
         return STATUS_INTERNAL_ERROR;
@@ -1787,6 +1918,89 @@ static NTSTATUS key_asymmetric_decrypt( void *args )
     return status;
 }

+static NTSTATUS key_secret_agreement( void *args )
+{
+    struct key_secret_agreement_params *params = args;
+    struct secret *secret;
+    struct key *priv_key;
+    struct key *peer_key;
+    int ret;
+
+    priv_key = params->privkey;
+    peer_key = params->pubkey;
+    secret = params->secret;
+
+    switch (priv_key->alg_id)
+    {
+        case ALG_ID_DH:
+        {
+            gnutls_datum_t prime, generator, priv, peer, secret_datum;
+            gnutls_dh_params_t dh_params;
+            ULONG key_length;
+
+            if (!dh_supported)
+            {
+                ERR("DH is not available.\n");
+                return STATUS_NOT_IMPLEMENTED;
+            }
+
+            if ((ret = pgnutls_dh_params_init( &dh_params )))
+            {
+                pgnutls_perror( ret );
+                return STATUS_INTERNAL_ERROR;
+            }
+
+            key_length = priv_key->u.a.bitlen / 8;
+
+            prime.size = generator.size = key_length;
+            prime.data = (UCHAR *)((BCRYPT_DH_KEY_BLOB *)priv_key->u.a.pubkey + 1);
+            generator.data = (BYTE *)((BCRYPT_DH_KEY_BLOB *)priv_key->u.a.pubkey + 1) + key_length;
+
+            if ((ret = pgnutls_dh_params_import_raw2( dh_params, &prime, &generator, priv_key->u.a.bitlen )))
+            {
+                pgnutls_perror( ret );
+                pgnutls_dh_params_deinit( dh_params );
+                return STATUS_INTERNAL_ERROR;
+            }
+
+            priv.size = peer.size = key_length;
+            priv.data = priv_key->u.a.privkey;
+            peer.data = peer_key->u.a.pubkey + sizeof(BCRYPT_DH_KEY_BLOB) + key_length * 2;
+
+            if (memcmp((BCRYPT_DH_KEY_BLOB *)priv_key->u.a.pubkey + 1,
+                    peer_key->u.a.pubkey + sizeof(BCRYPT_DH_KEY_BLOB), key_length * 2))
+            {
+                ERR("peer DH paramaters do not match.\n");
+                pgnutls_dh_params_deinit( dh_params );
+                return STATUS_INTERNAL_ERROR;
+            }
+
+            if ((ret = pgnutls_dh_compute_key( dh_params, &priv, NULL, &peer, &secret_datum )))
+            {
+                ERR("Error computing shared key.\n");
+                pgnutls_perror( ret );
+                pgnutls_dh_params_deinit( dh_params );
+                return STATUS_INTERNAL_ERROR;
+            }
+
+            TRACE("secret_datum.size %u, key_length %u.\n", secret_datum.size, key_length);
+            export_gnutls_datum( secret->data, key_length, &secret_datum, NULL );
+            secret->data_len = key_length;
+            free( secret_datum.data );
+            break;
+        }
+
+        case ALG_ID_ECDH_P256:
+            FIXME("ECDH is not supported.\n");
+            break;
+
+        default:
+            ERR( "unhandled algorithm %u\n", priv_key->alg_id );
+            return STATUS_INVALID_HANDLE;
+    }
+    return STATUS_SUCCESS;
+}
+
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     gnutls_process_attach,
@@ -1807,7 +2021,8 @@ unixlib_entry_t __wine_unix_call_funcs[] =
     key_export_ecc,
     key_import_dsa_capi,
     key_import_ecc,
-    key_import_rsa
+    key_import_rsa,
+    key_secret_agreement,
 };

 #ifdef _WIN64
diff --git a/include/bcrypt.h b/include/bcrypt.h
index a099f2f4b0e..7abcb50a43c 100644
--- a/include/bcrypt.h
+++ b/include/bcrypt.h
@@ -62,6 +62,8 @@ typedef LONG NTSTATUS;
 #define BCRYPT_OPAQUE_KEY_BLOB      L"OpaqueKeyBlob"
 #define BCRYPT_KEY_DATA_BLOB        L"KeyDataBlob"
 #define BCRYPT_AES_WRAP_KEY_BLOB    L"Rfc3565KeyWrapBlob"
+#define BCRYPT_DH_PUBLIC_BLOB       L"DHPUBLICBLOB"
+#define BCRYPT_DH_PRIVATE_BLOB      L"DHPRIVATEBLOB"
 #define BCRYPT_ECCPUBLIC_BLOB       L"ECCPUBLICBLOB"
 #define BCRYPT_ECCPRIVATE_BLOB      L"ECCPRIVATEBLOB"
 #define BCRYPT_RSAPUBLIC_BLOB       L"RSAPUBLICBLOB"
@@ -81,6 +83,7 @@ typedef LONG NTSTATUS;
 #define BCRYPT_3DES_ALGORITHM       L"3DES"
 #define BCRYPT_AES_ALGORITHM        L"AES"
 #define BCRYPT_DES_ALGORITHM        L"DES"
+#define BCRYPT_DH_ALGORITHM         L"DH"
 #define BCRYPT_DSA_ALGORITHM        L"DSA"
 #define BCRYPT_ECDH_P256_ALGORITHM  L"ECDH_P256"
 #define BCRYPT_ECDSA_P256_ALGORITHM L"ECDSA_P256"
@@ -111,6 +114,8 @@ typedef LONG NTSTATUS;
 #define BCRYPT_KDF_TLS_PRF          L"TLS_PRF"
 #define BCRYPT_KDF_SP80056A_CONCAT  L"SP800_56A_CONCAT"
 #define BCRYPT_KDF_RAW_SECRET       L"TRUNCATE"
+
+#define BCRYPT_DH_PARAMETERS        L"DHParameters"
 #else
 static const WCHAR BCRYPT_ALGORITHM_NAME[] = {'A','l','g','o','r','i','t','h','m','N','a','m','e',0};
 static const WCHAR BCRYPT_AUTH_TAG_LENGTH[] = {'A','u','t','h','T','a','g','L','e','n','g','t','h',0};
@@ -133,6 +138,8 @@ static const WCHAR BCRYPT_SIGNATURE_LENGTH[] = {'S','i','g','n','a','t','u','r',
 static const WCHAR BCRYPT_OPAQUE_KEY_BLOB[] = {'O','p','a','q','u','e','K','e','y','B','l','o','b',0};
 static const WCHAR BCRYPT_KEY_DATA_BLOB[] = {'K','e','y','D','a','t','a','B','l','o','b',0};
 static const WCHAR BCRYPT_AES_WRAP_KEY_BLOB[] = {'R','f','c','3','5','6','5','K','e','y','W','r','a','p','B','l','o','b',0};
+static const WCHAR BCRYPT_DH_PUBLIC_BLOB[] = {'D','H','P','U','B','L','I','C','B','L','O','B',0};
+static const WCHAR BCRYPT_DH_PRIVATE_BLOB[] = {'D','H','P','R','I','V','A','T','E','B','L','O','B',0};
 static const WCHAR BCRYPT_ECCPUBLIC_BLOB[] = {'E','C','C','P','U','B','L','I','C','B','L','O','B',0};
 static const WCHAR BCRYPT_ECCPRIVATE_BLOB[] = {'E','C','C','P','R','I','V','A','T','E','B','L','O','B',0};
 static const WCHAR BCRYPT_RSAPUBLIC_BLOB[] = {'R','S','A','P','U','B','L','I','C','B','L','O','B',0};
@@ -154,6 +161,7 @@ static const WCHAR MS_PLATFORM_CRYPTO_PROVIDER[] = \
 static const WCHAR BCRYPT_3DES_ALGORITHM[] = {'3','D','E','S',0};
 static const WCHAR BCRYPT_AES_ALGORITHM[] = {'A','E','S',0};
 static const WCHAR BCRYPT_DES_ALGORITHM[] = {'D','E','S',0};
+static const WCHAR BCRYPT_DH_ALGORITHM[] = {'D','H',0};
 static const WCHAR BCRYPT_DSA_ALGORITHM[] = {'D','S','A',0};
 static const WCHAR BCRYPT_ECDH_P256_ALGORITHM[] = {'E','C','D','H','_','P','2','5','6',0};
 static const WCHAR BCRYPT_ECDSA_P256_ALGORITHM[] = {'E','C','D','S','A','_','P','2','5','6',0};
@@ -184,6 +192,7 @@ static const WCHAR BCRYPT_KDF_HMAC[] = {'H','M','A','C',0};
 static const WCHAR BCRYPT_KDF_TLS_PRF[] = {'T','L','S','_','P','R','F',0};
 static const WCHAR BCRYPT_KDF_SP80056A_CONCAT[] = {'S','P','8','0','0','_','5','6','A','_','C','O','N','C','A','T',0};
 static const WCHAR BCRYPT_KDF_RAW_SECRET[] = {'T','R','U','N','C','A','T','E',0};
+#define BCRYPT_DH_PARAMETERS        u"DHParameters"
 #endif

 #define BCRYPT_ECDSA_PUBLIC_P256_MAGIC  0x31534345
@@ -298,6 +307,15 @@ typedef struct _BCRYPT_DSA_KEY_BLOB
 #define BCRYPT_DSA_PUBLIC_MAGIC_V2  0x32425044
 #define BCRYPT_DSA_PRIVATE_MAGIC_V2 0x32565044

+typedef struct _BCRYPT_DH_KEY_BLOB
+{
+    ULONG dwMagic;
+    ULONG cbKey;
+} BCRYPT_DH_KEY_BLOB, *PBCRYPT_DH_KEY_BLOB;
+
+#define BCRYPT_DH_PUBLIC_MAGIC  0x42504844
+#define BCRYPT_DH_PRIVATE_MAGIC 0x56504844
+
 typedef enum
 {
     DSA_HASH_ALGORITHM_SHA1,
@@ -357,6 +375,15 @@ typedef struct _BCRYPT_KEY_DATA_BLOB_HEADER
     ULONG cbKeyData;
 } BCRYPT_KEY_DATA_BLOB_HEADER, *PBCRYPT_KEY_DATA_BLOB_HEADER;

+typedef struct _BCRYPT_DH_PARAMETER_HEADER
+{
+    ULONG cbLength;
+    ULONG dwMagic;
+    ULONG cbKeyLength;
+} BCRYPT_DH_PARAMETER_HEADER;
+
+#define BCRYPT_DH_PARAMETERS_MAGIC 0x4d504844
+
 #define KDF_HASH_ALGORITHM 0x00000000
 #define KDF_SECRET_PREPEND 0x00000001
 #define KDF_SECRET_APPEND  0x00000002
@@ -386,6 +413,8 @@ typedef PVOID BCRYPT_HANDLE;
 typedef PVOID BCRYPT_HASH_HANDLE;
 typedef PVOID BCRYPT_SECRET_HANDLE;

+#define BCRYPT_NO_KEY_VALIDATION 0x00000008
+
 /* Flags for BCryptGenRandom */
 #define BCRYPT_RNG_USE_ENTROPY_IN_BUFFER 0x00000001
 #define BCRYPT_USE_SYSTEM_PREFERRED_RNG  0x00000002
--
2.31.1

From f1ebd91fae89bbf76c0e574a37685c11b78dcbd5 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 9 Dec 2020 20:10:13 +0300
Subject: [PATCH 2/6] bcrypt: Implement BCryptDeriveKey() for _KDF_RAW_SECRET.

Extracted from the patch implementing ECDH on top of gcrypt by Derek Lesho.
---
 dlls/bcrypt/bcrypt_main.c | 27 +++++++++++++++++++++++++--
 1 file changed, 25 insertions(+), 2 deletions(-)

diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
index 889f6ce85ea..48910aafe3c 100644
--- a/dlls/bcrypt/bcrypt_main.c
+++ b/dlls/bcrypt/bcrypt_main.c
@@ -2237,12 +2237,35 @@ NTSTATUS WINAPI BCryptDeriveKey(BCRYPT_SECRET_HANDLE handle, LPCWSTR kdf, BCrypt
 {
     struct secret *secret = handle;

-    FIXME( "%p, %s, %p, %p, %lu, %p, %#lx\n", secret, debugstr_w(kdf), parameter, derived, derived_size, result, flags );
+    TRACE( "%p, %s, %p, %p, %lu, %p, %#lx\n", secret, debugstr_w(kdf), parameter, derived, derived_size, result, flags );

     if (!secret || secret->hdr.magic != MAGIC_SECRET) return STATUS_INVALID_HANDLE;
     if (!kdf) return STATUS_INVALID_PARAMETER;

-    return STATUS_INTERNAL_ERROR;
+    if (flags) FIXME("flags ignored: %#lx\n", flags);
+
+    if (!(lstrcmpW( kdf, BCRYPT_KDF_RAW_SECRET )))
+    {
+        ULONG secret_length = secret->data_len;
+        unsigned int i;;
+
+        if (!derived)
+        {
+            *result = secret_length;
+            return STATUS_SUCCESS;
+        }
+
+        /* outputs in little endian for some reason */
+        for (i = 0; i < min(secret_length, derived_size); i++)
+        {
+            derived[i] = secret->data[secret_length - i - 1];
+        }
+
+        *result = i;
+        return STATUS_SUCCESS;
+    }
+    FIXME( "Derivation function %s not supported.\n", debugstr_w(kdf) );
+    return STATUS_NOT_IMPLEMENTED;
 }

 BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
--
2.31.1

From 0d0f5851874c79c1ceb7fe7cfb84738d754d73a9 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Tue, 7 Jan 2020 14:22:49 -0600
Subject: [PATCH 3/6] bcrypt: Implement BCRYPT_KDF_HASH.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47699
Signed-off-by: Derek Lesho <dlesho at codeweavers.com>
---
 dlls/bcrypt/bcrypt_main.c  | 107 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 107 insertions(+)

diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
index 48910aafe3c..e1742fa7a01 100644
--- a/dlls/bcrypt/bcrypt_main.c
+++ b/dlls/bcrypt/bcrypt_main.c
@@ -2244,7 +2244,112 @@ NTSTATUS WINAPI BCryptDeriveKey(BCRYPT_SECRET_HANDLE handle, LPCWSTR kdf, BCrypt

     if (flags) FIXME("flags ignored: %#lx\n", flags);

-    if (!(lstrcmpW( kdf, BCRYPT_KDF_RAW_SECRET )))
+    if (!(lstrcmpW( kdf, BCRYPT_KDF_HASH )))
+    {
+        unsigned int i;
+        BCryptBuffer *hash_algorithm = NULL;
+        BCryptBuffer *secret_prepend = NULL;
+        BCryptBuffer *secret_append = NULL;
+        enum alg_id hash_alg_id;
+        ULONG hash_length;
+        struct hash_impl hash;
+        NTSTATUS status;
+
+        if (parameter)
+        {
+            for (i = 0; i < parameter->cBuffers; i++)
+            {
+                BCryptBuffer *cur_buffer = &parameter->pBuffers[i];
+                switch(cur_buffer->BufferType)
+                {
+                case KDF_HASH_ALGORITHM:
+                    if (hash_algorithm)
+                        FIXME("Duplicate KDF_HASH_ALGORITHM, untested\n");
+                    hash_algorithm = cur_buffer;
+                    break;
+                case KDF_SECRET_PREPEND:
+                    if (secret_prepend)
+                        FIXME("Multiple prefixes unsupported\n");
+                    secret_prepend = cur_buffer;
+                    break;
+                case KDF_SECRET_APPEND:
+                    if (secret_append)
+                        FIXME("Multiple suffixes unsupported\n");
+                    secret_append = cur_buffer;
+                    break;
+                default:
+                    FIXME("Unsupported BCRYPT_KDF_HASH parameter type %x\n", cur_buffer->BufferType);
+                    break;
+                }
+            }
+        }
+
+        if (!(hash_algorithm))
+            hash_alg_id = ALG_ID_SHA1;
+        else
+        {
+            for (i = 0; i < ARRAY_SIZE( builtin_algorithms ); i++)
+            {
+                if (!lstrcmpW( hash_algorithm->pvBuffer, builtin_algorithms[i].name))
+                {
+                    hash_alg_id = i;
+                    break;
+                }
+            }
+            if (i == ARRAY_SIZE(builtin_algorithms))
+            {
+                WARN("Algorithm %s not found\n", debugstr_w(hash_algorithm->pvBuffer));
+                return STATUS_NOT_SUPPORTED;
+            }
+            if (builtin_algorithms[hash_alg_id].class != BCRYPT_HASH_INTERFACE)
+            {
+                WARN("Incorrect class %u\n", builtin_algorithms[hash_alg_id].class);
+                return STATUS_NOT_SUPPORTED;
+            }
+        }
+
+        hash_length = builtin_algorithms[hash_alg_id].hash_length;
+
+        if (!derived)
+        {
+            *result = hash_length;
+            return STATUS_SUCCESS;
+        }
+
+        if ((status = hash_init(&hash, hash_alg_id)))
+        {
+            return status;
+        }
+
+        if (secret_prepend)
+        {
+            hash_update(&hash, hash_alg_id, secret_prepend->pvBuffer, secret_prepend->cbBuffer);
+        }
+
+        hash_update(&hash, hash_alg_id, secret->data, secret->data_len);
+
+        if (secret_append)
+        {
+            hash_update(&hash, hash_alg_id, secret_append->pvBuffer, secret_append->cbBuffer);
+        }
+
+        if (derived_size >= hash_length)
+        {
+            hash_finish(&hash, hash_alg_id, derived, derived_size);
+            *result = hash_length;
+        }
+        else
+        {
+            UCHAR *output = malloc(hash_length);
+            hash_finish(&hash, hash_alg_id, output, hash_length);
+            memcpy(derived, output, derived_size);
+            free(output);
+            *result = derived_size;
+        }
+
+        return STATUS_SUCCESS;
+    }
+    else if (!(lstrcmpW( kdf, BCRYPT_KDF_RAW_SECRET )))
     {
         ULONG secret_length = secret->data_len;
         unsigned int i;;
2.31.1

From f56b6fb6a307d79609e35d464816b0d7295b80dd Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 11 Dec 2020 04:07:13 +0300
Subject: [PATCH 5/6] bcrypt: Reimplement DH using libgmp instead of private
 gnutls functions.

---
 configure               |  97 +++++++++++++
 configure.ac            |   8 ++
 dlls/bcrypt/Makefile.in |   2 +-
 dlls/bcrypt/gnutls.c    | 298 +++++++++++++++++++++++++++++-----------
 include/config.h.in     |   6 +
 5 files changed, 329 insertions(+), 82 deletions(-)

diff --git a/configure b/configure
index 8cc68a5cd55..9e70f3a9ea8 100755
--- a/configure
+++ b/configure
@@ -687,6 +687,8 @@ USB_LIBS
 USB_CFLAGS
 SANE_LIBS
 SANE_CFLAGS
+GMP_LIBS
+GMP_CFLAGS
 GNUTLS_LIBS
 GNUTLS_CFLAGS
 HAL_LIBS
@@ -1929,6 +1931,8 @@ HAL_CFLAGS
 HAL_LIBS
 GNUTLS_CFLAGS
 GNUTLS_LIBS
+GMP_CFLAGS
+GMP_LIBS
 SANE_CFLAGS
 SANE_LIBS
 USB_CFLAGS
@@ -2705,6 +2709,8 @@ Some influential environment variables:
   GNUTLS_CFLAGS
               C compiler flags for gnutls, overriding pkg-config
   GNUTLS_LIBS Linker flags for gnutls, overriding pkg-config
+  GMP_CFLAGS  C compiler flags for gmp, overriding pkg-config
+  GMP_LIBS    Linker flags for gmp, overriding pkg-config
   SANE_CFLAGS C compiler flags for sane-backends, overriding pkg-config
   SANE_LIBS   Linker flags for sane-backends, overriding pkg-config
   USB_CFLAGS  C compiler flags for libusb-1.0, overriding pkg-config
@@ -13629,6 +13635,95 @@ esac

 fi

+if test "x$with_gnutls" != "xno"
+then
+    if ${GMP_CFLAGS:+false} :; then :
+  if ${PKG_CONFIG+:} false; then :
+  GMP_CFLAGS=`$PKG_CONFIG --cflags gmp 2>/dev/null`
+fi
+fi
+
+if ${GMP_LIBS:+false} :; then :
+  if ${PKG_CONFIG+:} false; then :
+  GMP_LIBS=`$PKG_CONFIG --libs gmp 2>/dev/null`
+fi
+fi
+
+GMP_LIBS=${GMP_LIBS:-"-lgmp"}
+$as_echo "$as_me:${as_lineno-$LINENO}: gmp cflags: $GMP_CFLAGS" >&5
+$as_echo "$as_me:${as_lineno-$LINENO}: gmp libs: $GMP_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GMP_CFLAGS"
+for ac_header in gmp.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "gmp.h" "ac_cv_header_gmp_h" "$ac_includes_default"
+if test "x$ac_cv_header_gmp_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GMP_H 1
+_ACEOF
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lgmp" >&5
+$as_echo_n "checking for -lgmp... " >&6; }
+if ${ac_cv_lib_soname_gmp+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lgmp $GMP_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char __gmpz_init ();
+int
+main ()
+{
+return __gmpz_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_gmp=`$ac_cv_path_LDD conftest.exe | grep "gmp" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_gmp=`$OTOOL -L conftest$ac_exeext | grep "libgmp-*\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libgmp-*\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_gmp=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libgmp-*\\.$LIBEXT" | sed -e "s/^.*\\[\\(libgmp-*\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_gmp:+false} :; then :
+  ac_cv_lib_soname_gmp=`$LDD conftest$ac_exeext | grep "libgmp-*\\.$LIBEXT" | sed -e "s/^.*\(libgmp-*\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else
+  ac_cv_lib_soname_gmp=
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_gmp:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+       GMP_CFLAGS=""
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gmp" >&5
+$as_echo "$ac_cv_lib_soname_gmp" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBGMP "$ac_cv_lib_soname_gmp"
+_ACEOF
+
+
+fi
+fi
+
+done
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+
 if test "x$with_sane" != "xno"
 then
     if ${SANE_CFLAGS:+false} :; then :
@@ -19635,6 +19730,8 @@ HAL_CFLAGS = $HAL_CFLAGS
 HAL_LIBS = $HAL_LIBS
 GNUTLS_CFLAGS = $GNUTLS_CFLAGS
 GNUTLS_LIBS = $GNUTLS_LIBS
+GMP_CFLAGS = $GMP_CFLAGS
+GMP_LIBS = $GMP_LIBS
 SANE_CFLAGS = $SANE_CFLAGS
 SANE_LIBS = $SANE_LIBS
 USB_CFLAGS = $USB_CFLAGS
diff --git a/configure.ac b/configure.ac
index db8f0fea4fa..577a995a57d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1391,6 +1391,14 @@ fi
 WINE_WARNING_WITH(gnutls,[test "x$ac_cv_lib_soname_gnutls" = "x"],
                  [libgnutls ${notice_platform}development files not found, no schannel support.])

+dnl **** Check for libgmp ****
+if test "x$with_gnutls" != "xno"
+then
+    WINE_PACKAGE_FLAGS(GMP,[gmp],[-lgmp],,,
+        [AC_CHECK_HEADERS([gmp.h],
+            [WINE_CHECK_SONAME(gmp,__gmpz_init,,[GMP_CFLAGS=""],[$GMP_LIBS],[[libgmp-*]])])])
+fi
+
 dnl **** Check for SANE ****
 if test "x$with_sane" != "xno"
 then
diff --git a/dlls/bcrypt/Makefile.in b/dlls/bcrypt/Makefile.in
index 9f3510361c4..c5a0e202929 100644
--- a/dlls/bcrypt/Makefile.in
+++ b/dlls/bcrypt/Makefile.in
@@ -2,7 +2,7 @@ MODULE    = bcrypt.dll
 IMPORTS   = advapi32
 IMPORTLIB = bcrypt
 UNIXLIB   = bcrypt.so
-EXTRAINCL = $(GNUTLS_CFLAGS)
+EXTRAINCL = $(GNUTLS_CFLAGS) $(GMP_CFLAGS)

 C_SRCS = \
 	bcrypt_main.c \
diff --git a/dlls/bcrypt/gnutls.c b/dlls/bcrypt/gnutls.c
index a751310c883..66560c56358 100644
--- a/dlls/bcrypt/gnutls.c
+++ b/dlls/bcrypt/gnutls.c
@@ -47,6 +47,13 @@
 #include "wine/debug.h"
 #include "wine/unicode.h"

+#include <assert.h>
+
+#ifdef HAVE_GMP_H
+#include <gmp.h>
+#endif
+
+
 WINE_DEFAULT_DEBUG_CHANNEL(bcrypt);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);

@@ -80,8 +87,6 @@ static union key_data *key_data( struct key *key )
     return (union key_data *)key->private;
 }

-static BOOL dh_supported;
-
 /* Not present in gnutls version < 3.0 */
 static int (*pgnutls_cipher_tag)(gnutls_cipher_hd_t, void *, size_t);
 static int (*pgnutls_cipher_add_auth)(gnutls_cipher_hd_t, const void *, size_t);
@@ -124,11 +129,9 @@ static int (*pgnutls_dh_params_import_raw2)(gnutls_dh_params_t dh_params, const
         const gnutls_datum_t * generator, unsigned key_bits);
 static int (*pgnutls_dh_params_export_raw)(gnutls_dh_params_t params, gnutls_datum_t * prime,
         gnutls_datum_t * generator, unsigned int *bits);
-static int (*pgnutls_dh_generate_key)(gnutls_dh_params_t dh_params, gnutls_datum_t *priv_key, gnutls_datum_t *pub_key);
-static int (*pgnutls_dh_compute_key)(gnutls_dh_params_t dh_params, const gnutls_datum_t *priv_key,
-        const gnutls_datum_t *pub_key, const gnutls_datum_t *peer_key, gnutls_datum_t *Z);

 static void *libgnutls_handle;
+
 #define MAKE_FUNCPTR(f) static typeof(f) * p##f
 MAKE_FUNCPTR(gnutls_cipher_decrypt2);
 MAKE_FUNCPTR(gnutls_cipher_deinit);
@@ -146,6 +149,22 @@ MAKE_FUNCPTR(gnutls_privkey_init);
 MAKE_FUNCPTR(gnutls_privkey_sign_hash);
 MAKE_FUNCPTR(gnutls_pubkey_deinit);
 MAKE_FUNCPTR(gnutls_pubkey_init);
+
+#if defined(HAVE_GMP_H) && defined(SONAME_LIBGMP)
+static BOOL dh_supported;
+static void *libgmp_handle;
+
+MAKE_FUNCPTR(mpz_init);
+MAKE_FUNCPTR(mpz_clear);
+MAKE_FUNCPTR(mpz_cmp);
+MAKE_FUNCPTR(_mpz_cmp_ui);
+MAKE_FUNCPTR(mpz_sizeinbase);
+MAKE_FUNCPTR(mpz_import);
+MAKE_FUNCPTR(mpz_export);
+MAKE_FUNCPTR(mpz_mod);
+MAKE_FUNCPTR(mpz_powm);
+MAKE_FUNCPTR(mpz_sub_ui);
+#endif
 #undef MAKE_FUNCPTR

 static int compat_gnutls_cipher_tag(gnutls_cipher_hd_t handle, void *tag, size_t tag_size)
@@ -287,6 +306,37 @@ static NTSTATUS gnutls_process_attach( void *args )
     LOAD_FUNCPTR(gnutls_pubkey_init);
 #undef LOAD_FUNCPTR

+#if defined(HAVE_GMP_H) && defined(SONAME_LIBGMP)
+#define LOAD_FUNCPTR_STR(f) #f
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym( libgmp_handle, LOAD_FUNCPTR_STR(f) ))) \
+    { \
+        ERR( "failed to load %s\n", LOAD_FUNCPTR_STR(f) ); \
+        goto fail; \
+    }
+
+    if ((libgmp_handle = dlopen( SONAME_LIBGMP, RTLD_NOW )))
+    {
+        LOAD_FUNCPTR(mpz_init);
+        LOAD_FUNCPTR(mpz_clear);
+        LOAD_FUNCPTR(mpz_cmp);
+        LOAD_FUNCPTR(_mpz_cmp_ui);
+        LOAD_FUNCPTR(mpz_sizeinbase);
+        LOAD_FUNCPTR(mpz_import);
+        LOAD_FUNCPTR(mpz_export);
+        LOAD_FUNCPTR(mpz_mod);
+        LOAD_FUNCPTR(mpz_powm);
+        LOAD_FUNCPTR(mpz_sub_ui);
+    }
+    else
+    {
+        ERR_(winediag)( "failed to load libgmp, no support for DH\n" );
+        goto fail;
+    }
+#undef LOAD_FUNCPTR
+#undef LOAD_FUNCPTR_STR
+#endif
+
 #define LOAD_FUNCPTR_OPT(f) \
     if (!(p##f = dlsym( libgnutls_handle, #f ))) \
     { \
@@ -336,19 +386,13 @@ static NTSTATUS gnutls_process_attach( void *args )
     {
         WARN("gnutls_dh_params_export_raw not found\n");
     }
-    if (!(pgnutls_dh_generate_key = dlsym( libgnutls_handle, "_gnutls_dh_generate_key" ))
-            && !(pgnutls_dh_generate_key = dlsym( libgnutls_handle, "gnutls_dh_generate_key" )))
-    {
-        WARN("gnutls_dh_generate_key not found\n");
-    }
-    if (!(pgnutls_dh_compute_key = dlsym( libgnutls_handle, "_gnutls_dh_compute_key" ))
-            && !(pgnutls_dh_compute_key = dlsym( libgnutls_handle, "gnutls_dh_compute_key" )))
-    {
-        WARN("gnutls_dh_compute_key not found\n");
-    }

+#if defined(HAVE_GMP_H) && defined(SONAME_LIBGMP)
     dh_supported = pgnutls_dh_params_init && pgnutls_dh_params_generate2 && pgnutls_dh_params_import_raw2
-            && pgnutls_dh_generate_key && pgnutls_dh_compute_key;
+            && libgmp_handle;
+#else
+    ERR_(winediag)("Compiled without DH support.\n");
+#endif

     if (TRACE_ON( bcrypt ))
     {
@@ -361,6 +405,14 @@ static NTSTATUS gnutls_process_attach( void *args )
 fail:
     dlclose( libgnutls_handle );
     libgnutls_handle = NULL;
+
+#if defined(HAVE_GMP_H) && defined(SONAME_LIBGMP)
+    if (libgmp_handle)
+    {
+        dlclose( libgmp_handle );
+        libgmp_handle = NULL;
+    }
+#endif
     return STATUS_DLL_NOT_FOUND;
 }

@@ -373,6 +425,11 @@ static NTSTATUS gnutls_process_detach( void *args )
         libgnutls_handle = NULL;
     }
     return STATUS_SUCCESS;
+
+#if defined(HAVE_GMP_H) && defined(SONAME_LIBGMP)
+    dlclose( libgmp_handle );
+    libgmp_handle = NULL;
+#endif
 }

 struct buffer
@@ -882,12 +939,61 @@ static NTSTATUS export_gnutls_pubkey_dsa_capi( gnutls_privkey_t gnutls_key, cons
     return STATUS_SUCCESS;
 }

+#if defined(HAVE_GMP_H) && defined(SONAME_LIBGMP)
+static NTSTATUS CDECL gen_random(void *buffer, unsigned int length)
+{
+    unsigned int read_size;
+    int dev_random;
+
+    dev_random = open("/dev/urandom", O_RDONLY);
+    if (dev_random == -1)
+    {
+        FIXME("couldn't open /dev/urandom.\n");
+        return STATUS_INTERNAL_ERROR;
+    }
+
+    read_size = read(dev_random, buffer, length);
+    close(dev_random);
+    if (read_size != length)
+    {
+        FIXME("Could not read from /dev/urandom.");
+        return STATUS_INTERNAL_ERROR;
+    }
+    return STATUS_SUCCESS;
+}
+
+static void import_mpz(mpz_t value, const void *input, unsigned int length)
+{
+    pmpz_import(value, length, 1, 1, 0, 0, input);
+}
+
+static void export_mpz(void *output, unsigned int length, const mpz_t value)
+{
+    size_t export_length;
+    unsigned int offset;
+
+    export_length = (pmpz_sizeinbase(value, 2) + 7) / 8;
+    assert(export_length <= length);
+    offset = length - export_length;
+    memset(output, 0, offset);
+    pmpz_export((BYTE *)output + offset, &export_length, 1, 1, 0, 0, value);
+    if (!export_length)
+    {
+        ERR("Zero export length, value bits %u.\n", (unsigned)pmpz_sizeinbase(value, 2));
+        memset((BYTE *)output + offset, 0, length - offset);
+    }
+    else
+    {
+        assert(export_length + offset == length);
+    }
+}
+
 static NTSTATUS CDECL key_dh_generate( struct key *key )
 {
-    gnutls_datum_t prime, generator, privkey, pubkey;
     NTSTATUS status = STATUS_SUCCESS;
-    gnutls_dh_params_t dh_params;
+    mpz_t p, psub1, g, privkey, pubkey;
     ULONG key_length;
+    unsigned int i;
     int ret;

     if (!dh_supported)
@@ -896,22 +1002,18 @@ static NTSTATUS CDECL key_dh_generate( struct key *key )
         return STATUS_NOT_IMPLEMENTED;
     }

-    if ((ret = pgnutls_dh_params_init( &dh_params )))
-    {
-        pgnutls_perror( ret );
-        return STATUS_INTERNAL_ERROR;
-    }
-
     key_length = key->u.a.bitlen / 8;

     if (!(key->u.a.flags & KEY_FLAG_DH_PARAMS_SET))
     {
-        /* Generate parameters, export and then import them back below.
-         * The bitlen in dh parameters (which is later used for keys generation)
-         * is not set to gnutls_dh_params_generate2 'bits' parameter as one
-         * could expect. gnutls_dh_params_generate2 generates 'q' (which is not
-         * actually needed for DH) with the estimated bit length and then
-         * sets the bit length to the 'q' bitlength. */
+        gnutls_datum_t prime, generator;
+        gnutls_dh_params_t dh_params;
+
+        if ((ret = pgnutls_dh_params_init( &dh_params )))
+        {
+            pgnutls_perror( ret );
+            return STATUS_INTERNAL_ERROR;
+        }
         if ((ret = pgnutls_dh_params_generate2( dh_params, key->u.a.bitlen )))
         {
             pgnutls_perror( ret );
@@ -924,6 +1026,8 @@ static NTSTATUS CDECL key_dh_generate( struct key *key )
             pgnutls_dh_params_deinit( dh_params );
             return STATUS_INTERNAL_ERROR;
         }
+        pgnutls_dh_params_deinit( dh_params );
+

         export_gnutls_datum( (UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1), key_length, &prime, NULL );
         export_gnutls_datum( (UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + key_length,
@@ -934,34 +1038,73 @@ static NTSTATUS CDECL key_dh_generate( struct key *key )
         key->u.a.flags |= KEY_FLAG_DH_PARAMS_SET;
     }

-    prime.size = generator.size = key_length;
-    prime.data = (UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1);
-    generator.data = (BYTE *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + key_length;
+    pmpz_init(p);
+    pmpz_init(psub1);
+    pmpz_init(g);
+    pmpz_init(pubkey);
+    pmpz_init(privkey);

-    if ((ret = pgnutls_dh_params_import_raw2( dh_params, &prime, &generator, key->u.a.bitlen )))
+    import_mpz(p, (BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1, key_length);
+    if (!mpz_sgn(p))
     {
-        pgnutls_perror( ret );
-        pgnutls_dh_params_deinit( dh_params );
-        return STATUS_INTERNAL_ERROR;
+        ERR("Got zero modulus.\n");
+        status = STATUS_INTERNAL_ERROR;
+        goto done;
     }
+    pmpz_sub_ui(psub1, p, 1);

-    if ((ret = pgnutls_dh_generate_key( dh_params, &privkey, &pubkey )))
+    import_mpz(g, (UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + key_length, key_length);
+    if (!mpz_sgn(g))
     {
-        pgnutls_perror( ret );
-        pgnutls_dh_params_deinit( dh_params );
-        return STATUS_INTERNAL_ERROR;
+        ERR("Got zero generator.\n");
+        status = STATUS_INTERNAL_ERROR;
+        goto done;
+    }
+    for (i = 0; i < 3; ++i)
+    {
+        if ((status = gen_random(key->u.a.privkey, key_length)))
+        {
+            goto done;
+        }
+        import_mpz(privkey, key->u.a.privkey, key_length);
+
+        pmpz_mod(privkey, privkey, p);
+        pmpz_powm(pubkey, g, privkey, p);
+        if (p_mpz_cmp_ui(pubkey, 1))
+            break;
+    }
+    if (i == 3)
+    {
+        ERR("Could not generate key after 3 iterations.\n");
+        status = STATUS_INTERNAL_ERROR;
+        goto done;
     }

-    export_gnutls_datum( (BYTE *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + 2 * key_length,
-            key_length, &pubkey, NULL );
-    export_gnutls_datum( key->u.a.privkey, key_length, &privkey, NULL);
+    if (pmpz_cmp(pubkey, psub1) >= 0)
+    {
+        ERR("pubkey > p - 1.\n");
+        status = STATUS_INTERNAL_ERROR;
+        goto done;
+    }

-    free( privkey.data );
-    free( pubkey.data );
-    pgnutls_dh_params_deinit( dh_params );
+    export_mpz(key->u.a.privkey, key_length, privkey);
+    export_mpz((UCHAR *)((BCRYPT_DH_KEY_BLOB *)key->u.a.pubkey + 1) + 2 * key_length, key_length, pubkey);

+done:
+    pmpz_clear(psub1);
+    pmpz_clear(p);
+    pmpz_clear(g);
+    pmpz_clear(pubkey);
+    pmpz_clear(privkey);
     return status;
 }
+#else
+static NTSTATUS CDECL key_dh_generate( struct key *key )
+{
+    ERR("Compiled without DH support.\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+#endif

 static NTSTATUS key_asymmetric_generate( void *args )
 {
@@ -1924,8 +2067,6 @@ static NTSTATUS key_secret_agreement( void *args )
     struct secret *secret;
     struct key *priv_key;
     struct key *peer_key;
-    int ret;
-
     priv_key = params->privkey;
     peer_key = params->pubkey;
     secret = params->secret;
@@ -1933,9 +2074,9 @@ static NTSTATUS key_secret_agreement( void *args )
     switch (priv_key->alg_id)
     {
         case ALG_ID_DH:
+#if defined(HAVE_GMP_H) && defined(SONAME_LIBGMP)
         {
-            gnutls_datum_t prime, generator, priv, peer, secret_datum;
-            gnutls_dh_params_t dh_params;
+            mpz_t p, priv, peer, k;
             ULONG key_length;

             if (!dh_supported)
@@ -1944,51 +2085,46 @@ static NTSTATUS key_secret_agreement( void *args )
                 return STATUS_NOT_IMPLEMENTED;
             }

-            if ((ret = pgnutls_dh_params_init( &dh_params )))
-            {
-                pgnutls_perror( ret );
-                return STATUS_INTERNAL_ERROR;
-            }
-
             key_length = priv_key->u.a.bitlen / 8;

-            prime.size = generator.size = key_length;
-            prime.data = (UCHAR *)((BCRYPT_DH_KEY_BLOB *)priv_key->u.a.pubkey + 1);
-            generator.data = (BYTE *)((BCRYPT_DH_KEY_BLOB *)priv_key->u.a.pubkey + 1) + key_length;
-
-            if ((ret = pgnutls_dh_params_import_raw2( dh_params, &prime, &generator, priv_key->u.a.bitlen )))
-            {
-                pgnutls_perror( ret );
-                pgnutls_dh_params_deinit( dh_params );
-                return STATUS_INTERNAL_ERROR;
-            }
-
-            priv.size = peer.size = key_length;
-            priv.data = priv_key->u.a.privkey;
-            peer.data = peer_key->u.a.pubkey + sizeof(BCRYPT_DH_KEY_BLOB) + key_length * 2;
-
             if (memcmp((BCRYPT_DH_KEY_BLOB *)priv_key->u.a.pubkey + 1,
                     peer_key->u.a.pubkey + sizeof(BCRYPT_DH_KEY_BLOB), key_length * 2))
             {
                 ERR("peer DH paramaters do not match.\n");
-                pgnutls_dh_params_deinit( dh_params );
                 return STATUS_INTERNAL_ERROR;
             }

-            if ((ret = pgnutls_dh_compute_key( dh_params, &priv, NULL, &peer, &secret_datum )))
+            pmpz_init(p);
+            pmpz_init(priv);
+            pmpz_init(peer);
+            pmpz_init(k);
+
+            import_mpz(p, (BCRYPT_DH_KEY_BLOB *)priv_key->u.a.pubkey + 1, key_length);
+            if (pmpz_sizeinbase(p, 2) < 2)
             {
-                ERR("Error computing shared key.\n");
-                pgnutls_perror( ret );
-                pgnutls_dh_params_deinit( dh_params );
+                ERR("Invalid prime.\n");
+                pmpz_clear(p);
+                pmpz_clear(priv);
+                pmpz_clear(peer);
+                pmpz_clear(k);
                 return STATUS_INTERNAL_ERROR;
             }
-
-            TRACE("secret_datum.size %u, key_length %u.\n", secret_datum.size, key_length);
-            export_gnutls_datum( secret->data, key_length, &secret_datum, NULL );
+            import_mpz(priv, priv_key->u.a.privkey, key_length);
+            import_mpz(peer, peer_key->u.a.pubkey + sizeof(BCRYPT_DH_KEY_BLOB) + key_length * 2, key_length);
+            pmpz_powm(k, peer, priv, p);
+            export_mpz(secret->data, key_length, k);
             secret->data_len = key_length;
-            free( secret_datum.data );
+
+            pmpz_clear(p);
+            pmpz_clear(priv);
+            pmpz_clear(peer);
+            pmpz_clear(k);
             break;
         }
+#else
+            ERR_(winediag)("Compiled without DH support.\n");
+            return STATUS_NOT_IMPLEMENTED;
+#endif

         case ALG_ID_ECDH_P256:
             FIXME("ECDH is not supported.\n");
diff --git a/include/config.h.in b/include/config.h.in
index 13f160c1b00..56adcf3cfe5 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -135,6 +135,9 @@
 /* Define to 1 if you have the <gettext-po.h> header file. */
 #undef HAVE_GETTEXT_PO_H

+/* Define to 1 if you have the <gmp.h> header file. */
+#undef HAVE_GMP_H
+
 /* Define to 1 if you have the `gnutls_cipher_init' function. */
 #undef HAVE_GNUTLS_CIPHER_INIT

@@ -995,6 +998,9 @@
 /* Define to the soname of the libGLESv2 library. */
 #undef SONAME_LIBGLESV2

+/* Define to the soname of the libgmp library. */
+#undef SONAME_LIBGMP
+
 /* Define to the soname of the libgnutls library. */
 #undef SONAME_LIBGNUTLS

--
2.31.1

